import { app, BrowserWindow, ipcMain, Menu, shell } from "electron"
import path from "path"
import { initialize, tearDown } from "../../src/common"
import { WebviewProvider } from "../../src/core/webview"
import { AuthHandler } from "../../src/hosts/external/AuthHandler"
import { HostProvider } from "../../src/hosts/host-provider"
import { DiffViewProvider } from "../../src/integrations/editor/DiffViewProvider"
import { ExternalDiffViewProvider } from "../../src/hosts/external/ExternalDiffviewProvider"
import { ExternalWebviewProvider } from "../../src/hosts/external/ExternalWebviewProvider"
import { ExternalHostBridgeClientManager } from "../../src/hosts/external/host-bridge-client-manager"
import { WebviewProviderType } from "../../src/shared/webview/types"
import { startProtobusService, waitForHostBridgeReady } from "../../src/standalone/protobus-service"
import { log } from "../../src/standalone/utils"
import { createChannel, createClient } from "nice-grpc"
import { PROTOBUS_PORT } from "../../src/standalone/protobus-service"
import {
	AccountServiceDefinition,
	BrowserServiceDefinition,
	CheckpointsServiceDefinition,
	CommandsServiceDefinition,
	FileServiceDefinition,
	McpServiceDefinition,
	ModelsServiceDefinition,
	SlashServiceDefinition,
	StateServiceDefinition,
	TaskServiceDefinition,
	UiServiceDefinition,
	WebServiceDefinition,
} from "../../src/generated/nice-grpc/index.cline"

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
	app.quit()
}

let mainWindow: BrowserWindow | null = null
let webviewProvider: WebviewProvider | null = null

const createWindow = (): void => {
	// Create the browser window.
	mainWindow = new BrowserWindow({
		width: 1200,
		height: 800,
		minWidth: 800,
		minHeight: 600,
		webPreferences: {
			preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
			contextIsolation: true,
			nodeIntegration: false,
		},
		show: false, // Don't show until ready-to-show
		backgroundColor: "#1e1e1e", // Dark background to match VS Code theme
		icon: path.join(__dirname, "../../assets/icons/icon.png"),
	})

	// Create application menu
	createApplicationMenu()

	// and load the index.html of the app.
	mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY)

	// Show window when ready
	mainWindow.once("ready-to-show", () => {
		mainWindow?.show()
	})

	// Open external links in the default browser
	mainWindow.webContents.setWindowOpenHandler(({ url }) => {
		shell.openExternal(url)
		return { action: "deny" }
	})

	// Set up IPC listeners to handle gRPC requests from the renderer
	setupGrpcIpcBridge(mainWindow)

	// Set up additional IPC handlers for file system and app operations
	setupAdditionalIpcHandlers(mainWindow)
}

// Create application menu
function createApplicationMenu() {
	const isMac = process.platform === "darwin"

	const template = [
		// App menu (macOS only)
		...(isMac
			? [
					{
						label: app.name,
						submenu: [
							{ role: "about" },
							{ type: "separator" },
							{ role: "services" },
							{ type: "separator" },
							{ role: "hide" },
							{ role: "hideOthers" },
							{ role: "unhide" },
							{ type: "separator" },
							{ role: "quit" },
						],
					},
				]
			: []),
		// File menu
		{
			label: "File",
			submenu: [isMac ? { role: "close" } : { role: "quit" }],
		},
		// Edit menu
		{
			label: "Edit",
			submenu: [
				{ role: "undo" },
				{ role: "redo" },
				{ type: "separator" },
				{ role: "cut" },
				{ role: "copy" },
				{ role: "paste" },
				...(isMac
					? [
							{ role: "pasteAndMatchStyle" },
							{ role: "delete" },
							{ role: "selectAll" },
							{ type: "separator" },
							{
								label: "Speech",
								submenu: [{ role: "startSpeaking" }, { role: "stopSpeaking" }],
							},
						]
					: [{ role: "delete" }, { type: "separator" }, { role: "selectAll" }]),
			],
		},
		// View menu
		{
			label: "View",
			submenu: [
				{ role: "reload" },
				{ role: "forceReload" },
				{ role: "toggleDevTools" },
				{ type: "separator" },
				{ role: "resetZoom" },
				{ role: "zoomIn" },
				{ role: "zoomOut" },
				{ type: "separator" },
				{ role: "togglefullscreen" },
			],
		},
		// Window menu
		{
			label: "Window",
			submenu: [
				{ role: "minimize" },
				{ role: "zoom" },
				...(isMac
					? [{ type: "separator" }, { role: "front" }, { type: "separator" }, { role: "window" }]
					: [{ role: "close" }]),
			],
		},
		// Help menu
		{
			role: "help",
			submenu: [
				{
					label: "Learn More",
					click: async () => {
						await shell.openExternal("https://cline.bot")
					},
				},
				{
					label: "Documentation",
					click: async () => {
						await shell.openExternal("https://docs.cline.bot")
					},
				},
				{
					label: "Report Issue",
					click: async () => {
						await shell.openExternal("https://github.com/cline/cline/issues")
					},
				},
			],
		},
	]

	const menu = Menu.buildFromTemplate(template as any)
	Menu.setApplicationMenu(menu)
}

// Initialize Cline Core
async function initializeClineCore() {
	try {
		log("\n\n\nStarting Cline Core service...\n\n\n")

		// 暂时跳过健康检查，直接启动
		log("Skipping HostBridge health check in Electron environment")
		// await waitForHostBridgeReady();
		// log("HostBridge is serving; continuing startup");

		// Setup host provider
		setupHostProvider()

		// Set up global error handlers to prevent process crashes
		setupGlobalErrorHandlers()

		// Create extension context for Cline Core
		const extensionContext = {
			extension: {
				id: "saoudrizwan.claude-dev",
				isActive: true,
				extensionPath: app.getAppPath(),
				extensionUri: { fsPath: app.getAppPath() },
				packageJSON: require("../../package.json"),
				exports: undefined as any,
				activate: async (): Promise<void> => {},
				extensionKind: 1, // UI
			},
			extensionMode: app.isPackaged ? 1 : 2, // Production or Development
			globalState: {
				get: (key: string): any => null,
				update: (key: string, value: any) => Promise.resolve(),
				keys: (): readonly string[] => [],
				setKeysForSync: (): void => {},
			},
			secrets: {
				get: (key: string) => Promise.resolve(undefined),
				store: (key: string, value: string) => Promise.resolve(),
				delete: (key: string) => Promise.resolve(),
				onDidChange: (): { dispose: () => void } => ({ dispose: (): void => {} }),
			},
			storageUri: { fsPath: app.getPath("userData") },
			storagePath: app.getPath("userData"),
			globalStorageUri: { fsPath: app.getPath("userData") },
			globalStoragePath: app.getPath("userData"),
			logUri: { fsPath: app.getPath("logs") },
			logPath: app.getPath("logs"),
			extensionUri: { fsPath: app.getAppPath() },
			extensionPath: app.getAppPath(),
			asAbsolutePath: (relativePath: string) => path.join(app.getAppPath(), relativePath),
			subscriptions: [] as any[],
			environmentVariableCollection: {
				persistent: false,
				replace: (): void => {},
				append: (): void => {},
				prepend: (): void => {},
				get: (): any => undefined,
				forEach: (): void => {},
				delete: (): void => {},
				clear: (): void => {},
				getScoped: () => ({}) as any,
			},
			workspaceState: {
				get: (key: string): any => null,
				update: (key: string, value: any): Promise<void> => Promise.resolve(),
				keys: (): readonly string[] => [],
				setKeysForSync: (): void => {},
			},
		}

		// Initialize Cline Core
		webviewProvider = await initialize(extensionContext as any)

		AuthHandler.getInstance().setEnabled(true)

		// Start ProtoBus service (暂时跳过，因为健康检查在 Electron 中有问题)
		log("Skipping ProtoBus service startup in Electron environment")
		// startProtobusService(webviewProvider.controller);

		log("Cline Core service started successfully")
		return webviewProvider
	} catch (err) {
		log(`ERROR: Failed to initialize Cline Core: ${err}`)
		throw err
	}
}

function setupHostProvider() {
	const createWebview = (_: WebviewProviderType): WebviewProvider => {
		// 在Electron环境中，我们使用自定义的扩展上下文
		const electronExtensionContext = {
			extension: {
				id: "saoudrizwan.claude-dev",
				isActive: true,
				extensionPath: app.getAppPath(),
				extensionUri: { fsPath: app.getAppPath() },
				packageJSON: require("../../package.json"),
				exports: undefined as any,
				activate: async (): Promise<void> => {},
				extensionKind: 1, // UI
			},
			extensionMode: app.isPackaged ? 1 : 2, // Production or Development
			globalState: {
				get: (key: string): any => null,
				update: (key: string, value: any) => Promise.resolve(),
				keys: (): readonly string[] => [],
				setKeysForSync: (): void => {},
			},
			secrets: {
				get: (key: string) => Promise.resolve(undefined),
				store: (key: string, value: string) => Promise.resolve(),
				delete: (key: string) => Promise.resolve(),
				onDidChange: (): { dispose: () => void } => ({ dispose: (): void => {} }),
			},
			storageUri: { fsPath: app.getPath("userData") },
			storagePath: app.getPath("userData"),
			globalStorageUri: { fsPath: app.getPath("userData") },
			globalStoragePath: app.getPath("userData"),
			logUri: { fsPath: app.getPath("logs") },
			logPath: app.getPath("logs"),
			extensionUri: { fsPath: app.getAppPath() },
			extensionPath: app.getAppPath(),
			asAbsolutePath: (relativePath: string) => path.join(app.getAppPath(), relativePath),
			subscriptions: [] as any[],
			environmentVariableCollection: {
				persistent: false,
				replace: (): void => {},
				append: (): void => {},
				prepend: (): void => {},
				get: (): any => undefined,
				forEach: (): void => {},
				delete: (): void => {},
				clear: (): void => {},
				getScoped: () => ({}) as any,
			},
			workspaceState: {
				get: (key: string): any => null,
				update: (key: string, value: any) => Promise.resolve(),
				keys: (): readonly string[] => [],
				setKeysForSync: (): void => {},
			},
		}

		return new ExternalWebviewProvider(electronExtensionContext as any, WebviewProviderType.SIDEBAR)
	}

	const createDiffView = (): DiffViewProvider => {
		return new ExternalDiffViewProvider()
	}

	const getCallbackUri = (): Promise<string> => {
		return AuthHandler.getInstance().getCallbackUri()
	}

	HostProvider.initialize(createWebview, createDiffView, new ExternalHostBridgeClientManager(), log, getCallbackUri)
}

/**
 * Sets up global error handlers to prevent the process from crashing
 * on unhandled exceptions and promise rejections
 */
function setupGlobalErrorHandlers() {
	// Handle unhandled exceptions
	process.on("uncaughtException", (error: Error) => {
		console.error(`Uncaught exception: ${error.message}`)
		console.error(`Stack trace: ${error.stack}`)
		// Log the error but don't exit the process
	})

	// Handle unhandled promise rejections
	process.on("unhandledRejection", (reason: any, _promise: Promise<any>) => {
		console.error(`Unhandled promise rejection: ${reason}`)
		if (reason instanceof Error) {
			console.error(`Stack trace: ${reason.stack}`)
		}
		// Log the error but don't exit the process
	})

	// Handle process warnings (optional, for debugging)
	process.on("warning", (warning: Error) => {
		console.warn(`Process Warning: ${warning.name}: ${warning.message}`)
	})

	// Graceful shutdown handlers
	app.on("quit", () => {
		console.log("Application quitting, shutting down gracefully...")
		tearDown()
	})
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", async () => {
	// Set the user data path for the standalone core service.
	process.env.CLINE_DIR = app.getPath("userData")

	// Set the working directory to the webpack build path so proto files can be found
	const appPath = app.getAppPath()
	const webpackMainPath = path.join(appPath, ".webpack", "main")
	process.chdir(webpackMainPath)
	console.log(`Changed working directory to: ${webpackMainPath}`)
	console.log(`Current working directory: ${process.cwd()}`)

	try {
		// Debug: Check if proto files exist
		const fs = require("fs")
		const protoPath = path.join(process.cwd(), "proto", "descriptor_set.pb")
		console.log(`Checking proto file at: ${protoPath}`)
		console.log(`Proto file exists: ${fs.existsSync(protoPath)}`)

		// Initialize Cline Core
		await initializeClineCore()

		// Create the main window
		createWindow()
	} catch (error) {
		console.error("Failed to initialize application:", error)
		console.error("Error stack:", error.stack)
		app.exit(1)
	}
})

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
	if (process.platform !== "darwin") {
		app.quit()
	}
})

app.on("activate", () => {
	// On OS X it's common to re-create a window in the app when the
	// dock icon is clicked and there are no other windows open.
	if (BrowserWindow.getAllWindows().length === 0) {
		createWindow()
	}
})

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

// Setup additional IPC handlers for file system and app operations
function setupAdditionalIpcHandlers(mainWindow: BrowserWindow) {
	// File system operations
	ipcMain.on("fs-get-home-path", (event) => {
		event.reply("fs-home-path-response", app.getPath("home"))
	})

	ipcMain.on("fs-get-user-data-path", (event) => {
		event.reply("fs-user-data-path-response", app.getPath("userData"))
	})

	// App information
	ipcMain.on("app-get-version", (event) => {
		event.reply("app-version-response", app.getVersion())
	})
}

function setupGrpcIpcBridge(mainWindow: BrowserWindow) {
	const channel = createChannel(`http://localhost:${PROTOBUS_PORT}`)

	const clients = {
		"cline.AccountService": createClient(AccountServiceDefinition, channel),
		"cline.BrowserService": createClient(BrowserServiceDefinition, channel),
		"cline.CheckpointsService": createClient(CheckpointsServiceDefinition, channel),
		"cline.CommandsService": createClient(CommandsServiceDefinition, channel),
		"cline.FileService": createClient(FileServiceDefinition, channel),
		"cline.McpService": createClient(McpServiceDefinition, channel),
		"cline.ModelsService": createClient(ModelsServiceDefinition, channel),
		"cline.SlashService": createClient(SlashServiceDefinition, channel),
		"cline.StateService": createClient(StateServiceDefinition, channel),
		"cline.TaskService": createClient(TaskServiceDefinition, channel),
		"cline.UiService": createClient(UiServiceDefinition, channel),
		"cline.WebService": createClient(WebServiceDefinition, channel),
	}

	// Handle gRPC requests from renderer
	ipcMain.on("grpc-request", async (event, { service, method, request, requestId, is_streaming }) => {
		const client = clients[service as keyof typeof clients] as any
		if (!client) {
			const error = `Unknown service: ${service}`
			console.error(error)
			mainWindow.webContents.send("grpc-response", { requestId, error })
			return
		}

		try {
			if (is_streaming) {
				const stream = client[method](request)
				for await (const response of stream) {
					mainWindow.webContents.send("grpc-response", { requestId, message: response, is_streaming: true })
				}
				mainWindow.webContents.send("grpc-response", { requestId, is_streaming: false }) // End of stream
			} else {
				const response = await client[method](request)
				mainWindow.webContents.send("grpc-response", { requestId, message: response })
			}
		} catch (err: any) {
			console.error(`gRPC call failed for ${service}/${method}:`, err)
			mainWindow.webContents.send("grpc-response", { requestId, error: err.message || "gRPC call failed" })
		}
	})

	// Handle cancellation requests
	ipcMain.on("grpc-request-cancel", (event, { requestId }) => {
		// Cancellation in nice-grpc is handled via AbortController signals,
		// which is more complex to bridge over IPC. For now, we log the request.
		// A more robust implementation would track ongoing calls and abort them.
		console.log(`Cancellation requested for ${requestId}, but not yet implemented in IPC bridge.`)
	})
}
