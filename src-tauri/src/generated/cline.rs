// This file is @generated by prost-build.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Metadata {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EmptyRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Empty {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringArrayRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(string, repeated, tag = "2")]
    pub value: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct String {
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Int64Request {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(int64, tag = "2")]
    pub value: i64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Int64 {
    #[prost(int64, tag = "1")]
    pub value: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BytesRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bytes {
    #[prost(bytes = "vec", tag = "1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BooleanRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(bool, tag = "2")]
    pub value: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Boolean {
    #[prost(bool, tag = "1")]
    pub value: bool,
}
/// the same as Boolean, but avoiding name conflicts
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BooleanResponse {
    #[prost(bool, tag = "1")]
    pub value: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringArray {
    #[prost(string, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringArrays {
    #[prost(string, repeated, tag = "1")]
    pub values1: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub values2: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyValuePair {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileDiagnostics {
    #[prost(string, tag = "1")]
    pub file_path: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub diagnostics: ::prost::alloc::vec::Vec<Diagnostic>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Diagnostic {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub range: ::core::option::Option<DiagnosticRange>,
    #[prost(enumeration = "DiagnosticSeverity", tag = "3")]
    pub severity: i32,
    #[prost(string, optional, tag = "4")]
    pub source: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DiagnosticRange {
    #[prost(message, optional, tag = "1")]
    pub start: ::core::option::Option<DiagnosticPosition>,
    #[prost(message, optional, tag = "2")]
    pub end: ::core::option::Option<DiagnosticPosition>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DiagnosticPosition {
    #[prost(int32, tag = "1")]
    pub line: i32,
    #[prost(int32, tag = "2")]
    pub character: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DiagnosticSeverity {
    DiagnosticError = 0,
    DiagnosticWarning = 1,
    DiagnosticInformation = 2,
    DiagnosticHint = 3,
}
impl DiagnosticSeverity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DiagnosticError => "DIAGNOSTIC_ERROR",
            Self::DiagnosticWarning => "DIAGNOSTIC_WARNING",
            Self::DiagnosticInformation => "DIAGNOSTIC_INFORMATION",
            Self::DiagnosticHint => "DIAGNOSTIC_HINT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DIAGNOSTIC_ERROR" => Some(Self::DiagnosticError),
            "DIAGNOSTIC_WARNING" => Some(Self::DiagnosticWarning),
            "DIAGNOSTIC_INFORMATION" => Some(Self::DiagnosticInformation),
            "DIAGNOSTIC_HINT" => Some(Self::DiagnosticHint),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommandContext {
    /// The absolute path of the current file.
    #[prost(string, optional, tag = "1")]
    pub file_path: ::core::option::Option<::prost::alloc::string::String>,
    /// The selected source text.
    #[prost(string, optional, tag = "2")]
    pub selected_text: ::core::option::Option<::prost::alloc::string::String>,
    /// The language identifier for the current file.
    #[prost(string, optional, tag = "3")]
    pub language: ::core::option::Option<::prost::alloc::string::String>,
    /// Any diagnostic problems for the current file.
    #[prost(message, repeated, tag = "4")]
    pub diagnostics: ::prost::alloc::vec::Vec<Diagnostic>,
}
/// Generated server implementations.
pub mod commands_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CommandsServiceServer.
    #[async_trait]
    pub trait CommandsService: std::marker::Send + std::marker::Sync + 'static {
        async fn add_to_cline(
            &self,
            request: tonic::Request<super::CommandContext>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        async fn fix_with_cline(
            &self,
            request: tonic::Request<super::CommandContext>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        async fn explain_with_cline(
            &self,
            request: tonic::Request<super::CommandContext>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        async fn improve_with_cline(
            &self,
            request: tonic::Request<super::CommandContext>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
    }
    /// Service for running IDE commands, for example context menu actions,
    /// commands, etc.
    /// In contrast to the rest of the ProtoBus services, these are
    /// intended to be called by the IDE directly instead of through the webview,
    /// because they are triggered by interactions in the IDE.
    #[derive(Debug)]
    pub struct CommandsServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CommandsServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for CommandsServiceServer<T>
    where
        T: CommandsService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/cline.CommandsService/addToCline" => {
                    #[allow(non_camel_case_types)]
                    struct addToClineSvc<T: CommandsService>(pub Arc<T>);
                    impl<
                        T: CommandsService,
                    > tonic::server::UnaryService<super::CommandContext>
                    for addToClineSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CommandContext>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CommandsService>::add_to_cline(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = addToClineSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.CommandsService/fixWithCline" => {
                    #[allow(non_camel_case_types)]
                    struct fixWithClineSvc<T: CommandsService>(pub Arc<T>);
                    impl<
                        T: CommandsService,
                    > tonic::server::UnaryService<super::CommandContext>
                    for fixWithClineSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CommandContext>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CommandsService>::fix_with_cline(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = fixWithClineSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.CommandsService/explainWithCline" => {
                    #[allow(non_camel_case_types)]
                    struct explainWithClineSvc<T: CommandsService>(pub Arc<T>);
                    impl<
                        T: CommandsService,
                    > tonic::server::UnaryService<super::CommandContext>
                    for explainWithClineSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CommandContext>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CommandsService>::explain_with_cline(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = explainWithClineSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.CommandsService/improveWithCline" => {
                    #[allow(non_camel_case_types)]
                    struct improveWithClineSvc<T: CommandsService>(pub Arc<T>);
                    impl<
                        T: CommandsService,
                    > tonic::server::UnaryService<super::CommandContext>
                    for improveWithClineSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CommandContext>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CommandsService>::improve_with_cline(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = improveWithClineSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CommandsServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "cline.CommandsService";
    impl<T> tonic::server::NamedService for CommandsServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Request message for creating a new task
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewTaskRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(string, tag = "2")]
    pub text: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub images: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub files: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request message for toggling task favorite status
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskFavoriteRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(string, tag = "2")]
    pub task_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub is_favorited: bool,
}
/// Response for task details
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskResponse {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub task: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub ts: i64,
    #[prost(bool, tag = "4")]
    pub is_favorited: bool,
    #[prost(int64, tag = "5")]
    pub size: i64,
    #[prost(double, tag = "6")]
    pub total_cost: f64,
    #[prost(int32, tag = "7")]
    pub tokens_in: i32,
    #[prost(int32, tag = "8")]
    pub tokens_out: i32,
    #[prost(int32, tag = "9")]
    pub cache_writes: i32,
    #[prost(int32, tag = "10")]
    pub cache_reads: i32,
}
/// Request for getting task history with filtering
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTaskHistoryRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(bool, tag = "2")]
    pub favorites_only: bool,
    #[prost(string, tag = "3")]
    pub search_query: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub sort_by: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub current_workspace_only: bool,
}
/// Response for task history
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskHistoryArray {
    #[prost(message, repeated, tag = "1")]
    pub tasks: ::prost::alloc::vec::Vec<TaskItem>,
    #[prost(int32, tag = "2")]
    pub total_count: i32,
}
/// Task item details for history list
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskItem {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub task: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub ts: i64,
    #[prost(bool, tag = "4")]
    pub is_favorited: bool,
    #[prost(int64, tag = "5")]
    pub size: i64,
    #[prost(double, tag = "6")]
    pub total_cost: f64,
    #[prost(int32, tag = "7")]
    pub tokens_in: i32,
    #[prost(int32, tag = "8")]
    pub tokens_out: i32,
    #[prost(int32, tag = "9")]
    pub cache_writes: i32,
    #[prost(int32, tag = "10")]
    pub cache_reads: i32,
}
/// Request for ask response operation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AskResponseRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(string, tag = "2")]
    pub response_type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub text: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub images: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "5")]
    pub files: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request for executing a quick win task
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecuteQuickWinRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(string, tag = "2")]
    pub command: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
}
/// Results returned when deleting all task history
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteAllTaskHistoryCount {
    #[prost(int32, tag = "1")]
    pub tasks_deleted: i32,
}
/// Generated server implementations.
pub mod task_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with TaskServiceServer.
    #[async_trait]
    pub trait TaskService: std::marker::Send + std::marker::Sync + 'static {
        /// Cancels the currently running task
        async fn cancel_task(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        /// Clears the current task
        async fn clear_task(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        /// Gets the total size of all tasks
        async fn get_total_tasks_size(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<tonic::Response<super::Int64>, tonic::Status>;
        /// Deletes multiple tasks with the given IDs
        async fn delete_tasks_with_ids(
            &self,
            request: tonic::Request<super::StringArrayRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        /// Creates a new task with the given text and optional images
        async fn new_task(
            &self,
            request: tonic::Request<super::NewTaskRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        /// Shows a task with the specified ID
        async fn show_task_with_id(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::TaskResponse>, tonic::Status>;
        /// Exports a task with the given ID to markdown
        async fn export_task_with_id(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        /// Toggles the favorite status of a task
        async fn toggle_task_favorite(
            &self,
            request: tonic::Request<super::TaskFavoriteRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        /// Gets filtered task history
        async fn get_task_history(
            &self,
            request: tonic::Request<super::GetTaskHistoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TaskHistoryArray>,
            tonic::Status,
        >;
        /// Sends a response to a previous ask operation
        async fn ask_response(
            &self,
            request: tonic::Request<super::AskResponseRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        /// Records task feedback (thumbs up/down)
        async fn task_feedback(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        /// Shows task completion changes diff in a view
        async fn task_completion_view_changes(
            &self,
            request: tonic::Request<super::Int64Request>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        /// Executes a quick win task with command and title
        async fn execute_quick_win(
            &self,
            request: tonic::Request<super::ExecuteQuickWinRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        /// Deletes all task history
        async fn delete_all_task_history(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteAllTaskHistoryCount>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct TaskServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> TaskServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for TaskServiceServer<T>
    where
        T: TaskService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/cline.TaskService/cancelTask" => {
                    #[allow(non_camel_case_types)]
                    struct cancelTaskSvc<T: TaskService>(pub Arc<T>);
                    impl<T: TaskService> tonic::server::UnaryService<super::EmptyRequest>
                    for cancelTaskSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaskService>::cancel_task(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = cancelTaskSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.TaskService/clearTask" => {
                    #[allow(non_camel_case_types)]
                    struct clearTaskSvc<T: TaskService>(pub Arc<T>);
                    impl<T: TaskService> tonic::server::UnaryService<super::EmptyRequest>
                    for clearTaskSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaskService>::clear_task(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = clearTaskSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.TaskService/getTotalTasksSize" => {
                    #[allow(non_camel_case_types)]
                    struct getTotalTasksSizeSvc<T: TaskService>(pub Arc<T>);
                    impl<T: TaskService> tonic::server::UnaryService<super::EmptyRequest>
                    for getTotalTasksSizeSvc<T> {
                        type Response = super::Int64;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaskService>::get_total_tasks_size(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = getTotalTasksSizeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.TaskService/deleteTasksWithIds" => {
                    #[allow(non_camel_case_types)]
                    struct deleteTasksWithIdsSvc<T: TaskService>(pub Arc<T>);
                    impl<
                        T: TaskService,
                    > tonic::server::UnaryService<super::StringArrayRequest>
                    for deleteTasksWithIdsSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringArrayRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaskService>::delete_tasks_with_ids(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = deleteTasksWithIdsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.TaskService/newTask" => {
                    #[allow(non_camel_case_types)]
                    struct newTaskSvc<T: TaskService>(pub Arc<T>);
                    impl<
                        T: TaskService,
                    > tonic::server::UnaryService<super::NewTaskRequest>
                    for newTaskSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::NewTaskRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaskService>::new_task(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = newTaskSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.TaskService/showTaskWithId" => {
                    #[allow(non_camel_case_types)]
                    struct showTaskWithIdSvc<T: TaskService>(pub Arc<T>);
                    impl<
                        T: TaskService,
                    > tonic::server::UnaryService<super::StringRequest>
                    for showTaskWithIdSvc<T> {
                        type Response = super::TaskResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaskService>::show_task_with_id(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = showTaskWithIdSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.TaskService/exportTaskWithId" => {
                    #[allow(non_camel_case_types)]
                    struct exportTaskWithIdSvc<T: TaskService>(pub Arc<T>);
                    impl<
                        T: TaskService,
                    > tonic::server::UnaryService<super::StringRequest>
                    for exportTaskWithIdSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaskService>::export_task_with_id(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = exportTaskWithIdSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.TaskService/toggleTaskFavorite" => {
                    #[allow(non_camel_case_types)]
                    struct toggleTaskFavoriteSvc<T: TaskService>(pub Arc<T>);
                    impl<
                        T: TaskService,
                    > tonic::server::UnaryService<super::TaskFavoriteRequest>
                    for toggleTaskFavoriteSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TaskFavoriteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaskService>::toggle_task_favorite(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = toggleTaskFavoriteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.TaskService/getTaskHistory" => {
                    #[allow(non_camel_case_types)]
                    struct getTaskHistorySvc<T: TaskService>(pub Arc<T>);
                    impl<
                        T: TaskService,
                    > tonic::server::UnaryService<super::GetTaskHistoryRequest>
                    for getTaskHistorySvc<T> {
                        type Response = super::TaskHistoryArray;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTaskHistoryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaskService>::get_task_history(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = getTaskHistorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.TaskService/askResponse" => {
                    #[allow(non_camel_case_types)]
                    struct askResponseSvc<T: TaskService>(pub Arc<T>);
                    impl<
                        T: TaskService,
                    > tonic::server::UnaryService<super::AskResponseRequest>
                    for askResponseSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AskResponseRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaskService>::ask_response(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = askResponseSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.TaskService/taskFeedback" => {
                    #[allow(non_camel_case_types)]
                    struct taskFeedbackSvc<T: TaskService>(pub Arc<T>);
                    impl<
                        T: TaskService,
                    > tonic::server::UnaryService<super::StringRequest>
                    for taskFeedbackSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaskService>::task_feedback(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = taskFeedbackSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.TaskService/taskCompletionViewChanges" => {
                    #[allow(non_camel_case_types)]
                    struct taskCompletionViewChangesSvc<T: TaskService>(pub Arc<T>);
                    impl<T: TaskService> tonic::server::UnaryService<super::Int64Request>
                    for taskCompletionViewChangesSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::Int64Request>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaskService>::task_completion_view_changes(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = taskCompletionViewChangesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.TaskService/executeQuickWin" => {
                    #[allow(non_camel_case_types)]
                    struct executeQuickWinSvc<T: TaskService>(pub Arc<T>);
                    impl<
                        T: TaskService,
                    > tonic::server::UnaryService<super::ExecuteQuickWinRequest>
                    for executeQuickWinSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExecuteQuickWinRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaskService>::execute_quick_win(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = executeQuickWinSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.TaskService/deleteAllTaskHistory" => {
                    #[allow(non_camel_case_types)]
                    struct deleteAllTaskHistorySvc<T: TaskService>(pub Arc<T>);
                    impl<T: TaskService> tonic::server::UnaryService<super::EmptyRequest>
                    for deleteAllTaskHistorySvc<T> {
                        type Response = super::DeleteAllTaskHistoryCount;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaskService>::delete_all_task_history(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = deleteAllTaskHistorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for TaskServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "cline.TaskService";
    impl<T> tonic::server::NamedService for TaskServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Response for refreshRules operation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefreshedRules {
    #[prost(message, optional, tag = "1")]
    pub global_cline_rules_toggles: ::core::option::Option<ClineRulesToggles>,
    #[prost(message, optional, tag = "2")]
    pub local_cline_rules_toggles: ::core::option::Option<ClineRulesToggles>,
    #[prost(message, optional, tag = "3")]
    pub local_cursor_rules_toggles: ::core::option::Option<ClineRulesToggles>,
    #[prost(message, optional, tag = "4")]
    pub local_windsurf_rules_toggles: ::core::option::Option<ClineRulesToggles>,
    #[prost(message, optional, tag = "5")]
    pub local_workflow_toggles: ::core::option::Option<ClineRulesToggles>,
    #[prost(message, optional, tag = "6")]
    pub global_workflow_toggles: ::core::option::Option<ClineRulesToggles>,
}
/// Request to toggle a Windsurf rule
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToggleWindsurfRuleRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    /// Path to the rule file
    #[prost(string, tag = "2")]
    pub rule_path: ::prost::alloc::string::String,
    /// Whether to enable or disable the rule
    #[prost(bool, tag = "3")]
    pub enabled: bool,
}
/// Request to convert a list of URIs to relative paths
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelativePathsRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(string, repeated, tag = "2")]
    pub uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response containing the converted relative paths
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelativePaths {
    #[prost(string, repeated, tag = "1")]
    pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request for file search operations
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileSearchRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    /// Search query string
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    /// Optional request ID for tracking requests
    #[prost(string, optional, tag = "3")]
    pub mentions_request_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional limit for results (default: 20)
    #[prost(int32, optional, tag = "4")]
    pub limit: ::core::option::Option<i32>,
    /// Optional selected type filter
    #[prost(enumeration = "FileSearchType", optional, tag = "5")]
    pub selected_type: ::core::option::Option<i32>,
}
/// Result for file search operations
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileSearchResults {
    /// Array of file/folder results
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<FileInfo>,
    /// Echo of the request ID for tracking
    #[prost(string, optional, tag = "2")]
    pub mentions_request_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// File information structure for search results
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileInfo {
    /// Relative path from workspace root
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// "file" or "folder"
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    /// Display name (usually basename)
    #[prost(string, optional, tag = "3")]
    pub label: ::core::option::Option<::prost::alloc::string::String>,
}
/// Response for searchCommits
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitCommits {
    #[prost(message, repeated, tag = "1")]
    pub commits: ::prost::alloc::vec::Vec<GitCommit>,
}
/// Represents a Git commit
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitCommit {
    #[prost(string, tag = "1")]
    pub hash: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub short_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub subject: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub author: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub date: ::prost::alloc::string::String,
}
/// Unified request for all rule file operations
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuleFileRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    /// Common field for all operations
    #[prost(bool, tag = "2")]
    pub is_global: bool,
    /// Path field for deleteRuleFile (optional)
    #[prost(string, optional, tag = "3")]
    pub rule_path: ::core::option::Option<::prost::alloc::string::String>,
    /// Filename field for createRuleFile (optional)
    #[prost(string, optional, tag = "4")]
    pub filename: ::core::option::Option<::prost::alloc::string::String>,
    /// Type of the file to create (optional)
    #[prost(string, optional, tag = "5")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Result for rule file operations with meaningful data only
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuleFile {
    /// Path to the rule file
    #[prost(string, tag = "1")]
    pub file_path: ::prost::alloc::string::String,
    /// Filename for display purposes
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// For createRuleFile, indicates if file already existed
    #[prost(bool, tag = "3")]
    pub already_exists: bool,
}
/// Request to toggle a Cline rule
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToggleClineRuleRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    /// Whether this is a global rule or workspace rule
    #[prost(bool, tag = "2")]
    pub is_global: bool,
    /// Path to the rule file
    #[prost(string, tag = "3")]
    pub rule_path: ::prost::alloc::string::String,
    /// Whether to enable or disable the rule
    #[prost(bool, tag = "4")]
    pub enabled: bool,
}
/// Maps from filepath to enabled/disabled status, matching app's ClineRulesToggles type
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClineRulesToggles {
    #[prost(map = "string, bool", tag = "1")]
    pub toggles: ::std::collections::HashMap<::prost::alloc::string::String, bool>,
}
/// Response for toggleClineRule operation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToggleClineRules {
    #[prost(message, optional, tag = "1")]
    pub global_cline_rules_toggles: ::core::option::Option<ClineRulesToggles>,
    #[prost(message, optional, tag = "2")]
    pub local_cline_rules_toggles: ::core::option::Option<ClineRulesToggles>,
}
/// Request to toggle a Cursor rule
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToggleCursorRuleRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    /// Path to the rule file
    #[prost(string, tag = "2")]
    pub rule_path: ::prost::alloc::string::String,
    /// Whether to enable or disable the rule
    #[prost(bool, tag = "3")]
    pub enabled: bool,
}
/// Request to toggle a workflow on or off
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToggleWorkflowRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(string, tag = "2")]
    pub workflow_path: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub enabled: bool,
    #[prost(bool, tag = "4")]
    pub is_global: bool,
}
/// Enum for file search type filtering
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FileSearchType {
    File = 0,
    Folder = 1,
}
impl FileSearchType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::File => "FILE",
            Self::Folder => "FOLDER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FILE" => Some(Self::File),
            "FOLDER" => Some(Self::Folder),
            _ => None,
        }
    }
}
/// Generated server implementations.
pub mod file_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with FileServiceServer.
    #[async_trait]
    pub trait FileService: std::marker::Send + std::marker::Sync + 'static {
        /// Copies text to clipboard
        async fn copy_to_clipboard(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        /// Opens a file in the editor
        async fn open_file(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        /// Opens an image in the system viewer
        async fn open_image(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        /// Opens a mention (file, path, git commit, problem, terminal, or URL)
        async fn open_mention(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        /// Deletes a rule file from either global or workspace rules directory
        async fn delete_rule_file(
            &self,
            request: tonic::Request<super::RuleFileRequest>,
        ) -> std::result::Result<tonic::Response<super::RuleFile>, tonic::Status>;
        /// Creates a rule file from either global or workspace rules directory
        async fn create_rule_file(
            &self,
            request: tonic::Request<super::RuleFileRequest>,
        ) -> std::result::Result<tonic::Response<super::RuleFile>, tonic::Status>;
        /// Search git commits in the workspace
        async fn search_commits(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::GitCommits>, tonic::Status>;
        /// Select images and other files from the file system and returns as data URLs & paths respectively
        async fn select_files(
            &self,
            request: tonic::Request<super::BooleanRequest>,
        ) -> std::result::Result<tonic::Response<super::StringArrays>, tonic::Status>;
        /// Convert URIs to workspace-relative paths
        async fn get_relative_paths(
            &self,
            request: tonic::Request<super::RelativePathsRequest>,
        ) -> std::result::Result<tonic::Response<super::RelativePaths>, tonic::Status>;
        /// Search for files in the workspace with fuzzy matching
        async fn search_files(
            &self,
            request: tonic::Request<super::FileSearchRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FileSearchResults>,
            tonic::Status,
        >;
        /// Toggle a Cline rule (enable or disable)
        async fn toggle_cline_rule(
            &self,
            request: tonic::Request<super::ToggleClineRuleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ToggleClineRules>,
            tonic::Status,
        >;
        /// Toggle a Cursor rule (enable or disable)
        async fn toggle_cursor_rule(
            &self,
            request: tonic::Request<super::ToggleCursorRuleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ClineRulesToggles>,
            tonic::Status,
        >;
        /// Toggle a Windsurf rule (enable or disable)
        async fn toggle_windsurf_rule(
            &self,
            request: tonic::Request<super::ToggleWindsurfRuleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ClineRulesToggles>,
            tonic::Status,
        >;
        /// Refreshes all rule toggles (Cline, External, and Workflows)
        async fn refresh_rules(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<tonic::Response<super::RefreshedRules>, tonic::Status>;
        /// Opens a task's conversation history file on disk
        async fn open_task_history(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        /// Toggles a workflow on or off
        async fn toggle_workflow(
            &self,
            request: tonic::Request<super::ToggleWorkflowRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ClineRulesToggles>,
            tonic::Status,
        >;
        /// Check if file exists in the project
        async fn if_file_exists_relative_path(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::BooleanResponse>, tonic::Status>;
        /// Open a file in editor by a relative path
        async fn open_file_relative_path(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        /// Opens or creates a focus chain checklist markdown file for editing
        async fn open_focus_chain_file(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
    }
    /// Service for file-related operations
    #[derive(Debug)]
    pub struct FileServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> FileServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for FileServiceServer<T>
    where
        T: FileService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/cline.FileService/copyToClipboard" => {
                    #[allow(non_camel_case_types)]
                    struct copyToClipboardSvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::UnaryService<super::StringRequest>
                    for copyToClipboardSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::copy_to_clipboard(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = copyToClipboardSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.FileService/openFile" => {
                    #[allow(non_camel_case_types)]
                    struct openFileSvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::UnaryService<super::StringRequest>
                    for openFileSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::open_file(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = openFileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.FileService/openImage" => {
                    #[allow(non_camel_case_types)]
                    struct openImageSvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::UnaryService<super::StringRequest>
                    for openImageSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::open_image(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = openImageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.FileService/openMention" => {
                    #[allow(non_camel_case_types)]
                    struct openMentionSvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::UnaryService<super::StringRequest>
                    for openMentionSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::open_mention(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = openMentionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.FileService/deleteRuleFile" => {
                    #[allow(non_camel_case_types)]
                    struct deleteRuleFileSvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::UnaryService<super::RuleFileRequest>
                    for deleteRuleFileSvc<T> {
                        type Response = super::RuleFile;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RuleFileRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::delete_rule_file(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = deleteRuleFileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.FileService/createRuleFile" => {
                    #[allow(non_camel_case_types)]
                    struct createRuleFileSvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::UnaryService<super::RuleFileRequest>
                    for createRuleFileSvc<T> {
                        type Response = super::RuleFile;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RuleFileRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::create_rule_file(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = createRuleFileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.FileService/searchCommits" => {
                    #[allow(non_camel_case_types)]
                    struct searchCommitsSvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::UnaryService<super::StringRequest>
                    for searchCommitsSvc<T> {
                        type Response = super::GitCommits;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::search_commits(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = searchCommitsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.FileService/selectFiles" => {
                    #[allow(non_camel_case_types)]
                    struct selectFilesSvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::UnaryService<super::BooleanRequest>
                    for selectFilesSvc<T> {
                        type Response = super::StringArrays;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BooleanRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::select_files(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = selectFilesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.FileService/getRelativePaths" => {
                    #[allow(non_camel_case_types)]
                    struct getRelativePathsSvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::UnaryService<super::RelativePathsRequest>
                    for getRelativePathsSvc<T> {
                        type Response = super::RelativePaths;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RelativePathsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::get_relative_paths(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = getRelativePathsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.FileService/searchFiles" => {
                    #[allow(non_camel_case_types)]
                    struct searchFilesSvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::UnaryService<super::FileSearchRequest>
                    for searchFilesSvc<T> {
                        type Response = super::FileSearchResults;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FileSearchRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::search_files(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = searchFilesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.FileService/toggleClineRule" => {
                    #[allow(non_camel_case_types)]
                    struct toggleClineRuleSvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::UnaryService<super::ToggleClineRuleRequest>
                    for toggleClineRuleSvc<T> {
                        type Response = super::ToggleClineRules;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ToggleClineRuleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::toggle_cline_rule(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = toggleClineRuleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.FileService/toggleCursorRule" => {
                    #[allow(non_camel_case_types)]
                    struct toggleCursorRuleSvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::UnaryService<super::ToggleCursorRuleRequest>
                    for toggleCursorRuleSvc<T> {
                        type Response = super::ClineRulesToggles;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ToggleCursorRuleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::toggle_cursor_rule(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = toggleCursorRuleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.FileService/toggleWindsurfRule" => {
                    #[allow(non_camel_case_types)]
                    struct toggleWindsurfRuleSvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::UnaryService<super::ToggleWindsurfRuleRequest>
                    for toggleWindsurfRuleSvc<T> {
                        type Response = super::ClineRulesToggles;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ToggleWindsurfRuleRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::toggle_windsurf_rule(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = toggleWindsurfRuleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.FileService/refreshRules" => {
                    #[allow(non_camel_case_types)]
                    struct refreshRulesSvc<T: FileService>(pub Arc<T>);
                    impl<T: FileService> tonic::server::UnaryService<super::EmptyRequest>
                    for refreshRulesSvc<T> {
                        type Response = super::RefreshedRules;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::refresh_rules(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = refreshRulesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.FileService/openTaskHistory" => {
                    #[allow(non_camel_case_types)]
                    struct openTaskHistorySvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::UnaryService<super::StringRequest>
                    for openTaskHistorySvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::open_task_history(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = openTaskHistorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.FileService/toggleWorkflow" => {
                    #[allow(non_camel_case_types)]
                    struct toggleWorkflowSvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::UnaryService<super::ToggleWorkflowRequest>
                    for toggleWorkflowSvc<T> {
                        type Response = super::ClineRulesToggles;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ToggleWorkflowRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::toggle_workflow(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = toggleWorkflowSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.FileService/ifFileExistsRelativePath" => {
                    #[allow(non_camel_case_types)]
                    struct ifFileExistsRelativePathSvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::UnaryService<super::StringRequest>
                    for ifFileExistsRelativePathSvc<T> {
                        type Response = super::BooleanResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::if_file_exists_relative_path(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ifFileExistsRelativePathSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.FileService/openFileRelativePath" => {
                    #[allow(non_camel_case_types)]
                    struct openFileRelativePathSvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::UnaryService<super::StringRequest>
                    for openFileRelativePathSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::open_file_relative_path(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = openFileRelativePathSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.FileService/openFocusChainFile" => {
                    #[allow(non_camel_case_types)]
                    struct openFocusChainFileSvc<T: FileService>(pub Arc<T>);
                    impl<
                        T: FileService,
                    > tonic::server::UnaryService<super::StringRequest>
                    for openFocusChainFileSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as FileService>::open_focus_chain_file(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = openFocusChainFileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for FileServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "cline.FileService";
    impl<T> tonic::server::NamedService for FileServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Define a new message type for webview provider info
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WebviewProviderTypeRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(enumeration = "WebviewProviderType", tag = "2")]
    pub provider_type: i32,
}
/// Message for conversation history deleted range
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversationHistoryDeletedRange {
    #[prost(int32, tag = "1")]
    pub start_index: i32,
    #[prost(int32, tag = "2")]
    pub end_index: i32,
}
/// Message for ClineSayTool
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClineSayTool {
    #[prost(enumeration = "ClineSayToolType", tag = "1")]
    pub tool: i32,
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub diff: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub content: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub regex: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub file_pattern: ::prost::alloc::string::String,
    #[prost(bool, tag = "7")]
    pub operation_is_located_in_workspace: bool,
}
/// Message for ClineSayBrowserAction
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClineSayBrowserAction {
    #[prost(enumeration = "BrowserAction", tag = "1")]
    pub action: i32,
    #[prost(string, tag = "2")]
    pub coordinate: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub text: ::prost::alloc::string::String,
}
/// Message for BrowserActionResult
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrowserActionResult {
    #[prost(string, tag = "1")]
    pub screenshot: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub logs: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub current_url: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub current_mouse_position: ::prost::alloc::string::String,
}
/// Message for ClineAskUseMcpServer
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClineAskUseMcpServer {
    #[prost(string, tag = "1")]
    pub server_name: ::prost::alloc::string::String,
    #[prost(enumeration = "McpServerRequestType", tag = "2")]
    pub r#type: i32,
    #[prost(string, tag = "3")]
    pub tool_name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub arguments: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub uri: ::prost::alloc::string::String,
}
/// Message for ClinePlanModeResponse
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClinePlanModeResponse {
    #[prost(string, tag = "1")]
    pub response: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub selected: ::prost::alloc::string::String,
}
/// Message for ClineAskQuestion
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClineAskQuestion {
    #[prost(string, tag = "1")]
    pub question: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub selected: ::prost::alloc::string::String,
}
/// Message for ClineAskNewTask
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClineAskNewTask {
    #[prost(string, tag = "1")]
    pub context: ::prost::alloc::string::String,
}
/// Message for API request retry status
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApiReqRetryStatus {
    #[prost(int32, tag = "1")]
    pub attempt: i32,
    #[prost(int32, tag = "2")]
    pub max_attempts: i32,
    #[prost(int32, tag = "3")]
    pub delay_sec: i32,
    #[prost(string, tag = "4")]
    pub error_snippet: ::prost::alloc::string::String,
}
/// Message for ClineApiReqInfo
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClineApiReqInfo {
    #[prost(string, tag = "1")]
    pub request: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub tokens_in: i32,
    #[prost(int32, tag = "3")]
    pub tokens_out: i32,
    #[prost(int32, tag = "4")]
    pub cache_writes: i32,
    #[prost(int32, tag = "5")]
    pub cache_reads: i32,
    #[prost(double, tag = "6")]
    pub cost: f64,
    #[prost(enumeration = "ClineApiReqCancelReason", tag = "7")]
    pub cancel_reason: i32,
    #[prost(string, tag = "8")]
    pub streaming_failed_message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "9")]
    pub retry_status: ::core::option::Option<ApiReqRetryStatus>,
}
/// Main ClineMessage type
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClineMessage {
    #[prost(int64, tag = "1")]
    pub ts: i64,
    #[prost(enumeration = "ClineMessageType", tag = "2")]
    pub r#type: i32,
    #[prost(enumeration = "ClineAsk", tag = "3")]
    pub ask: i32,
    #[prost(enumeration = "ClineSay", tag = "4")]
    pub say: i32,
    #[prost(string, tag = "5")]
    pub text: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub reasoning: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "7")]
    pub images: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "8")]
    pub files: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "9")]
    pub partial: bool,
    #[prost(string, tag = "10")]
    pub last_checkpoint_hash: ::prost::alloc::string::String,
    #[prost(bool, tag = "11")]
    pub is_checkpoint_checked_out: bool,
    #[prost(bool, tag = "12")]
    pub is_operation_outside_workspace: bool,
    #[prost(int32, tag = "13")]
    pub conversation_history_index: i32,
    #[prost(message, optional, tag = "14")]
    pub conversation_history_deleted_range: ::core::option::Option<
        ConversationHistoryDeletedRange,
    >,
    /// Additional fields for specific ask/say types
    #[prost(message, optional, tag = "15")]
    pub say_tool: ::core::option::Option<ClineSayTool>,
    #[prost(message, optional, tag = "16")]
    pub say_browser_action: ::core::option::Option<ClineSayBrowserAction>,
    #[prost(message, optional, tag = "17")]
    pub browser_action_result: ::core::option::Option<BrowserActionResult>,
    #[prost(message, optional, tag = "18")]
    pub ask_use_mcp_server: ::core::option::Option<ClineAskUseMcpServer>,
    #[prost(message, optional, tag = "19")]
    pub plan_mode_response: ::core::option::Option<ClinePlanModeResponse>,
    #[prost(message, optional, tag = "20")]
    pub ask_question: ::core::option::Option<ClineAskQuestion>,
    #[prost(message, optional, tag = "21")]
    pub ask_new_task: ::core::option::Option<ClineAskNewTask>,
    #[prost(message, optional, tag = "22")]
    pub api_req_info: ::core::option::Option<ClineApiReqInfo>,
}
/// Enum for webview provider types
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WebviewProviderType {
    Sidebar = 0,
    Tab = 1,
}
impl WebviewProviderType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Sidebar => "SIDEBAR",
            Self::Tab => "TAB",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIDEBAR" => Some(Self::Sidebar),
            "TAB" => Some(Self::Tab),
            _ => None,
        }
    }
}
/// Enum for ClineMessage type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClineMessageType {
    Ask = 0,
    Say = 1,
}
impl ClineMessageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Ask => "ASK",
            Self::Say => "SAY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ASK" => Some(Self::Ask),
            "SAY" => Some(Self::Say),
            _ => None,
        }
    }
}
/// Enum for ClineAsk types
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClineAsk {
    Followup = 0,
    PlanModeRespond = 1,
    Command = 2,
    CommandOutput = 3,
    CompletionResult = 4,
    Tool = 5,
    ApiReqFailed = 6,
    ResumeTask = 7,
    ResumeCompletedTask = 8,
    MistakeLimitReached = 9,
    AutoApprovalMaxReqReached = 10,
    BrowserActionLaunch = 11,
    UseMcpServer = 12,
    NewTask = 13,
    Condense = 14,
    ReportBug = 15,
    SummarizeTask = 16,
}
impl ClineAsk {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Followup => "FOLLOWUP",
            Self::PlanModeRespond => "PLAN_MODE_RESPOND",
            Self::Command => "COMMAND",
            Self::CommandOutput => "COMMAND_OUTPUT",
            Self::CompletionResult => "COMPLETION_RESULT",
            Self::Tool => "TOOL",
            Self::ApiReqFailed => "API_REQ_FAILED",
            Self::ResumeTask => "RESUME_TASK",
            Self::ResumeCompletedTask => "RESUME_COMPLETED_TASK",
            Self::MistakeLimitReached => "MISTAKE_LIMIT_REACHED",
            Self::AutoApprovalMaxReqReached => "AUTO_APPROVAL_MAX_REQ_REACHED",
            Self::BrowserActionLaunch => "BROWSER_ACTION_LAUNCH",
            Self::UseMcpServer => "USE_MCP_SERVER",
            Self::NewTask => "NEW_TASK",
            Self::Condense => "CONDENSE",
            Self::ReportBug => "REPORT_BUG",
            Self::SummarizeTask => "SUMMARIZE_TASK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FOLLOWUP" => Some(Self::Followup),
            "PLAN_MODE_RESPOND" => Some(Self::PlanModeRespond),
            "COMMAND" => Some(Self::Command),
            "COMMAND_OUTPUT" => Some(Self::CommandOutput),
            "COMPLETION_RESULT" => Some(Self::CompletionResult),
            "TOOL" => Some(Self::Tool),
            "API_REQ_FAILED" => Some(Self::ApiReqFailed),
            "RESUME_TASK" => Some(Self::ResumeTask),
            "RESUME_COMPLETED_TASK" => Some(Self::ResumeCompletedTask),
            "MISTAKE_LIMIT_REACHED" => Some(Self::MistakeLimitReached),
            "AUTO_APPROVAL_MAX_REQ_REACHED" => Some(Self::AutoApprovalMaxReqReached),
            "BROWSER_ACTION_LAUNCH" => Some(Self::BrowserActionLaunch),
            "USE_MCP_SERVER" => Some(Self::UseMcpServer),
            "NEW_TASK" => Some(Self::NewTask),
            "CONDENSE" => Some(Self::Condense),
            "REPORT_BUG" => Some(Self::ReportBug),
            "SUMMARIZE_TASK" => Some(Self::SummarizeTask),
            _ => None,
        }
    }
}
/// Enum for ClineSay types
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClineSay {
    Task = 0,
    Error = 1,
    ApiReqStarted = 2,
    ApiReqFinished = 3,
    Text = 4,
    Reasoning = 5,
    CompletionResultSay = 6,
    UserFeedback = 7,
    UserFeedbackDiff = 8,
    ApiReqRetried = 9,
    CommandSay = 10,
    CommandOutputSay = 11,
    ToolSay = 12,
    ShellIntegrationWarning = 13,
    BrowserActionLaunchSay = 14,
    BrowserAction = 15,
    BrowserActionResult = 16,
    McpServerRequestStarted = 17,
    McpServerResponse = 18,
    McpNotification = 19,
    UseMcpServerSay = 20,
    DiffError = 21,
    DeletedApiReqs = 22,
    ClineignoreError = 23,
    CheckpointCreated = 24,
    LoadMcpDocumentation = 25,
    Info = 26,
    TaskProgress = 27,
}
impl ClineSay {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Task => "TASK",
            Self::Error => "ERROR",
            Self::ApiReqStarted => "API_REQ_STARTED",
            Self::ApiReqFinished => "API_REQ_FINISHED",
            Self::Text => "TEXT",
            Self::Reasoning => "REASONING",
            Self::CompletionResultSay => "COMPLETION_RESULT_SAY",
            Self::UserFeedback => "USER_FEEDBACK",
            Self::UserFeedbackDiff => "USER_FEEDBACK_DIFF",
            Self::ApiReqRetried => "API_REQ_RETRIED",
            Self::CommandSay => "COMMAND_SAY",
            Self::CommandOutputSay => "COMMAND_OUTPUT_SAY",
            Self::ToolSay => "TOOL_SAY",
            Self::ShellIntegrationWarning => "SHELL_INTEGRATION_WARNING",
            Self::BrowserActionLaunchSay => "BROWSER_ACTION_LAUNCH_SAY",
            Self::BrowserAction => "BROWSER_ACTION",
            Self::BrowserActionResult => "BROWSER_ACTION_RESULT",
            Self::McpServerRequestStarted => "MCP_SERVER_REQUEST_STARTED",
            Self::McpServerResponse => "MCP_SERVER_RESPONSE",
            Self::McpNotification => "MCP_NOTIFICATION",
            Self::UseMcpServerSay => "USE_MCP_SERVER_SAY",
            Self::DiffError => "DIFF_ERROR",
            Self::DeletedApiReqs => "DELETED_API_REQS",
            Self::ClineignoreError => "CLINEIGNORE_ERROR",
            Self::CheckpointCreated => "CHECKPOINT_CREATED",
            Self::LoadMcpDocumentation => "LOAD_MCP_DOCUMENTATION",
            Self::Info => "INFO",
            Self::TaskProgress => "TASK_PROGRESS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TASK" => Some(Self::Task),
            "ERROR" => Some(Self::Error),
            "API_REQ_STARTED" => Some(Self::ApiReqStarted),
            "API_REQ_FINISHED" => Some(Self::ApiReqFinished),
            "TEXT" => Some(Self::Text),
            "REASONING" => Some(Self::Reasoning),
            "COMPLETION_RESULT_SAY" => Some(Self::CompletionResultSay),
            "USER_FEEDBACK" => Some(Self::UserFeedback),
            "USER_FEEDBACK_DIFF" => Some(Self::UserFeedbackDiff),
            "API_REQ_RETRIED" => Some(Self::ApiReqRetried),
            "COMMAND_SAY" => Some(Self::CommandSay),
            "COMMAND_OUTPUT_SAY" => Some(Self::CommandOutputSay),
            "TOOL_SAY" => Some(Self::ToolSay),
            "SHELL_INTEGRATION_WARNING" => Some(Self::ShellIntegrationWarning),
            "BROWSER_ACTION_LAUNCH_SAY" => Some(Self::BrowserActionLaunchSay),
            "BROWSER_ACTION" => Some(Self::BrowserAction),
            "BROWSER_ACTION_RESULT" => Some(Self::BrowserActionResult),
            "MCP_SERVER_REQUEST_STARTED" => Some(Self::McpServerRequestStarted),
            "MCP_SERVER_RESPONSE" => Some(Self::McpServerResponse),
            "MCP_NOTIFICATION" => Some(Self::McpNotification),
            "USE_MCP_SERVER_SAY" => Some(Self::UseMcpServerSay),
            "DIFF_ERROR" => Some(Self::DiffError),
            "DELETED_API_REQS" => Some(Self::DeletedApiReqs),
            "CLINEIGNORE_ERROR" => Some(Self::ClineignoreError),
            "CHECKPOINT_CREATED" => Some(Self::CheckpointCreated),
            "LOAD_MCP_DOCUMENTATION" => Some(Self::LoadMcpDocumentation),
            "INFO" => Some(Self::Info),
            "TASK_PROGRESS" => Some(Self::TaskProgress),
            _ => None,
        }
    }
}
/// Enum for ClineSayTool tool types
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClineSayToolType {
    EditedExistingFile = 0,
    NewFileCreated = 1,
    ReadFile = 2,
    ListFilesTopLevel = 3,
    ListFilesRecursive = 4,
    ListCodeDefinitionNames = 5,
    SearchFiles = 6,
    WebFetch = 7,
}
impl ClineSayToolType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EditedExistingFile => "EDITED_EXISTING_FILE",
            Self::NewFileCreated => "NEW_FILE_CREATED",
            Self::ReadFile => "READ_FILE",
            Self::ListFilesTopLevel => "LIST_FILES_TOP_LEVEL",
            Self::ListFilesRecursive => "LIST_FILES_RECURSIVE",
            Self::ListCodeDefinitionNames => "LIST_CODE_DEFINITION_NAMES",
            Self::SearchFiles => "SEARCH_FILES",
            Self::WebFetch => "WEB_FETCH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EDITED_EXISTING_FILE" => Some(Self::EditedExistingFile),
            "NEW_FILE_CREATED" => Some(Self::NewFileCreated),
            "READ_FILE" => Some(Self::ReadFile),
            "LIST_FILES_TOP_LEVEL" => Some(Self::ListFilesTopLevel),
            "LIST_FILES_RECURSIVE" => Some(Self::ListFilesRecursive),
            "LIST_CODE_DEFINITION_NAMES" => Some(Self::ListCodeDefinitionNames),
            "SEARCH_FILES" => Some(Self::SearchFiles),
            "WEB_FETCH" => Some(Self::WebFetch),
            _ => None,
        }
    }
}
/// Enum for browser actions
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BrowserAction {
    Launch = 0,
    Click = 1,
    Type = 2,
    ScrollDown = 3,
    ScrollUp = 4,
    Close = 5,
}
impl BrowserAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Launch => "LAUNCH",
            Self::Click => "CLICK",
            Self::Type => "TYPE",
            Self::ScrollDown => "SCROLL_DOWN",
            Self::ScrollUp => "SCROLL_UP",
            Self::Close => "CLOSE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LAUNCH" => Some(Self::Launch),
            "CLICK" => Some(Self::Click),
            "TYPE" => Some(Self::Type),
            "SCROLL_DOWN" => Some(Self::ScrollDown),
            "SCROLL_UP" => Some(Self::ScrollUp),
            "CLOSE" => Some(Self::Close),
            _ => None,
        }
    }
}
/// Enum for MCP server request types
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum McpServerRequestType {
    UseMcpTool = 0,
    AccessMcpResource = 1,
}
impl McpServerRequestType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UseMcpTool => "USE_MCP_TOOL",
            Self::AccessMcpResource => "ACCESS_MCP_RESOURCE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "USE_MCP_TOOL" => Some(Self::UseMcpTool),
            "ACCESS_MCP_RESOURCE" => Some(Self::AccessMcpResource),
            _ => None,
        }
    }
}
/// Enum for API request cancel reasons
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClineApiReqCancelReason {
    StreamingFailed = 0,
    UserCancelled = 1,
    RetriesExhausted = 2,
}
impl ClineApiReqCancelReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::StreamingFailed => "STREAMING_FAILED",
            Self::UserCancelled => "USER_CANCELLED",
            Self::RetriesExhausted => "RETRIES_EXHAUSTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STREAMING_FAILED" => Some(Self::StreamingFailed),
            "USER_CANCELLED" => Some(Self::UserCancelled),
            "RETRIES_EXHAUSTED" => Some(Self::RetriesExhausted),
            _ => None,
        }
    }
}
/// Generated server implementations.
pub mod ui_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with UiServiceServer.
    #[async_trait]
    pub trait UiService: std::marker::Send + std::marker::Sync + 'static {
        /// Scrolls to a specific settings section in the settings view
        async fn scroll_to_settings(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::KeyValuePair>, tonic::Status>;
        /// Marks the current announcement as shown and returns whether an announcement should still be shown
        async fn on_did_show_announcement(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<tonic::Response<super::Boolean>, tonic::Status>;
        /// Server streaming response type for the subscribeToAddToInput method.
        type subscribeToAddToInputStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::String, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to addToInput events (when user adds content via context menu)
        async fn subscribe_to_add_to_input(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::subscribeToAddToInputStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the subscribeToMcpButtonClicked method.
        type subscribeToMcpButtonClickedStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::Empty, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to MCP button clicked events
        async fn subscribe_to_mcp_button_clicked(
            &self,
            request: tonic::Request<super::WebviewProviderTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::subscribeToMcpButtonClickedStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the subscribeToHistoryButtonClicked method.
        type subscribeToHistoryButtonClickedStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::Empty, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to history button click events
        async fn subscribe_to_history_button_clicked(
            &self,
            request: tonic::Request<super::WebviewProviderTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::subscribeToHistoryButtonClickedStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the subscribeToChatButtonClicked method.
        type subscribeToChatButtonClickedStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::Empty, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to chat button clicked events (when the chat button is clicked in VSCode)
        async fn subscribe_to_chat_button_clicked(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::subscribeToChatButtonClickedStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the subscribeToAccountButtonClicked method.
        type subscribeToAccountButtonClickedStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::Empty, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to account button click events
        async fn subscribe_to_account_button_clicked(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::subscribeToAccountButtonClickedStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the subscribeToSettingsButtonClicked method.
        type subscribeToSettingsButtonClickedStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::Empty, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to settings button clicked events
        async fn subscribe_to_settings_button_clicked(
            &self,
            request: tonic::Request<super::WebviewProviderTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::subscribeToSettingsButtonClickedStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the subscribeToPartialMessage method.
        type subscribeToPartialMessageStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ClineMessage, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to partial message updates (streaming Cline messages as they're built)
        async fn subscribe_to_partial_message(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::subscribeToPartialMessageStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the subscribeToTheme method.
        type subscribeToThemeStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::String, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to theme change events
        async fn subscribe_to_theme(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::subscribeToThemeStream>,
            tonic::Status,
        >;
        /// Initialize webview when it launches
        async fn initialize_webview(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        /// Server streaming response type for the subscribeToRelinquishControl method.
        type subscribeToRelinquishControlStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::Empty, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to relinquish control events
        async fn subscribe_to_relinquish_control(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::subscribeToRelinquishControlStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the subscribeToFocusChatInput method.
        type subscribeToFocusChatInputStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::Empty, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to focus chat input events with client ID
        async fn subscribe_to_focus_chat_input(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::subscribeToFocusChatInputStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the subscribeToDidBecomeVisible method.
        type subscribeToDidBecomeVisibleStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::Empty, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to webview visibility change events
        async fn subscribe_to_did_become_visible(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::subscribeToDidBecomeVisibleStream>,
            tonic::Status,
        >;
        /// Returns the HTML for the webview index page. This is only used by external clients, not by the vscode webview.
        async fn get_webview_html(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<tonic::Response<super::String>, tonic::Status>;
        /// Opens a URL in the default browser
        async fn open_url(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        /// Opens the Cline walkthrough
        async fn open_walkthrough(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
    }
    /// UiService provides methods for managing UI interactions
    #[derive(Debug)]
    pub struct UiServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> UiServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for UiServiceServer<T>
    where
        T: UiService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/cline.UiService/scrollToSettings" => {
                    #[allow(non_camel_case_types)]
                    struct scrollToSettingsSvc<T: UiService>(pub Arc<T>);
                    impl<T: UiService> tonic::server::UnaryService<super::StringRequest>
                    for scrollToSettingsSvc<T> {
                        type Response = super::KeyValuePair;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UiService>::scroll_to_settings(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = scrollToSettingsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.UiService/onDidShowAnnouncement" => {
                    #[allow(non_camel_case_types)]
                    struct onDidShowAnnouncementSvc<T: UiService>(pub Arc<T>);
                    impl<T: UiService> tonic::server::UnaryService<super::EmptyRequest>
                    for onDidShowAnnouncementSvc<T> {
                        type Response = super::Boolean;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UiService>::on_did_show_announcement(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = onDidShowAnnouncementSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.UiService/subscribeToAddToInput" => {
                    #[allow(non_camel_case_types)]
                    struct subscribeToAddToInputSvc<T: UiService>(pub Arc<T>);
                    impl<
                        T: UiService,
                    > tonic::server::ServerStreamingService<super::StringRequest>
                    for subscribeToAddToInputSvc<T> {
                        type Response = super::String;
                        type ResponseStream = T::subscribeToAddToInputStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UiService>::subscribe_to_add_to_input(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = subscribeToAddToInputSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.UiService/subscribeToMcpButtonClicked" => {
                    #[allow(non_camel_case_types)]
                    struct subscribeToMcpButtonClickedSvc<T: UiService>(pub Arc<T>);
                    impl<
                        T: UiService,
                    > tonic::server::ServerStreamingService<
                        super::WebviewProviderTypeRequest,
                    > for subscribeToMcpButtonClickedSvc<T> {
                        type Response = super::Empty;
                        type ResponseStream = T::subscribeToMcpButtonClickedStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::WebviewProviderTypeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UiService>::subscribe_to_mcp_button_clicked(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = subscribeToMcpButtonClickedSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.UiService/subscribeToHistoryButtonClicked" => {
                    #[allow(non_camel_case_types)]
                    struct subscribeToHistoryButtonClickedSvc<T: UiService>(pub Arc<T>);
                    impl<
                        T: UiService,
                    > tonic::server::ServerStreamingService<
                        super::WebviewProviderTypeRequest,
                    > for subscribeToHistoryButtonClickedSvc<T> {
                        type Response = super::Empty;
                        type ResponseStream = T::subscribeToHistoryButtonClickedStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::WebviewProviderTypeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UiService>::subscribe_to_history_button_clicked(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = subscribeToHistoryButtonClickedSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.UiService/subscribeToChatButtonClicked" => {
                    #[allow(non_camel_case_types)]
                    struct subscribeToChatButtonClickedSvc<T: UiService>(pub Arc<T>);
                    impl<
                        T: UiService,
                    > tonic::server::ServerStreamingService<super::EmptyRequest>
                    for subscribeToChatButtonClickedSvc<T> {
                        type Response = super::Empty;
                        type ResponseStream = T::subscribeToChatButtonClickedStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UiService>::subscribe_to_chat_button_clicked(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = subscribeToChatButtonClickedSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.UiService/subscribeToAccountButtonClicked" => {
                    #[allow(non_camel_case_types)]
                    struct subscribeToAccountButtonClickedSvc<T: UiService>(pub Arc<T>);
                    impl<
                        T: UiService,
                    > tonic::server::ServerStreamingService<super::EmptyRequest>
                    for subscribeToAccountButtonClickedSvc<T> {
                        type Response = super::Empty;
                        type ResponseStream = T::subscribeToAccountButtonClickedStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UiService>::subscribe_to_account_button_clicked(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = subscribeToAccountButtonClickedSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.UiService/subscribeToSettingsButtonClicked" => {
                    #[allow(non_camel_case_types)]
                    struct subscribeToSettingsButtonClickedSvc<T: UiService>(pub Arc<T>);
                    impl<
                        T: UiService,
                    > tonic::server::ServerStreamingService<
                        super::WebviewProviderTypeRequest,
                    > for subscribeToSettingsButtonClickedSvc<T> {
                        type Response = super::Empty;
                        type ResponseStream = T::subscribeToSettingsButtonClickedStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::WebviewProviderTypeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UiService>::subscribe_to_settings_button_clicked(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = subscribeToSettingsButtonClickedSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.UiService/subscribeToPartialMessage" => {
                    #[allow(non_camel_case_types)]
                    struct subscribeToPartialMessageSvc<T: UiService>(pub Arc<T>);
                    impl<
                        T: UiService,
                    > tonic::server::ServerStreamingService<super::EmptyRequest>
                    for subscribeToPartialMessageSvc<T> {
                        type Response = super::ClineMessage;
                        type ResponseStream = T::subscribeToPartialMessageStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UiService>::subscribe_to_partial_message(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = subscribeToPartialMessageSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.UiService/subscribeToTheme" => {
                    #[allow(non_camel_case_types)]
                    struct subscribeToThemeSvc<T: UiService>(pub Arc<T>);
                    impl<
                        T: UiService,
                    > tonic::server::ServerStreamingService<super::EmptyRequest>
                    for subscribeToThemeSvc<T> {
                        type Response = super::String;
                        type ResponseStream = T::subscribeToThemeStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UiService>::subscribe_to_theme(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = subscribeToThemeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.UiService/initializeWebview" => {
                    #[allow(non_camel_case_types)]
                    struct initializeWebviewSvc<T: UiService>(pub Arc<T>);
                    impl<T: UiService> tonic::server::UnaryService<super::EmptyRequest>
                    for initializeWebviewSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UiService>::initialize_webview(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = initializeWebviewSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.UiService/subscribeToRelinquishControl" => {
                    #[allow(non_camel_case_types)]
                    struct subscribeToRelinquishControlSvc<T: UiService>(pub Arc<T>);
                    impl<
                        T: UiService,
                    > tonic::server::ServerStreamingService<super::EmptyRequest>
                    for subscribeToRelinquishControlSvc<T> {
                        type Response = super::Empty;
                        type ResponseStream = T::subscribeToRelinquishControlStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UiService>::subscribe_to_relinquish_control(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = subscribeToRelinquishControlSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.UiService/subscribeToFocusChatInput" => {
                    #[allow(non_camel_case_types)]
                    struct subscribeToFocusChatInputSvc<T: UiService>(pub Arc<T>);
                    impl<
                        T: UiService,
                    > tonic::server::ServerStreamingService<super::StringRequest>
                    for subscribeToFocusChatInputSvc<T> {
                        type Response = super::Empty;
                        type ResponseStream = T::subscribeToFocusChatInputStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UiService>::subscribe_to_focus_chat_input(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = subscribeToFocusChatInputSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.UiService/subscribeToDidBecomeVisible" => {
                    #[allow(non_camel_case_types)]
                    struct subscribeToDidBecomeVisibleSvc<T: UiService>(pub Arc<T>);
                    impl<
                        T: UiService,
                    > tonic::server::ServerStreamingService<super::EmptyRequest>
                    for subscribeToDidBecomeVisibleSvc<T> {
                        type Response = super::Empty;
                        type ResponseStream = T::subscribeToDidBecomeVisibleStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UiService>::subscribe_to_did_become_visible(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = subscribeToDidBecomeVisibleSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.UiService/getWebviewHtml" => {
                    #[allow(non_camel_case_types)]
                    struct getWebviewHtmlSvc<T: UiService>(pub Arc<T>);
                    impl<T: UiService> tonic::server::UnaryService<super::EmptyRequest>
                    for getWebviewHtmlSvc<T> {
                        type Response = super::String;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UiService>::get_webview_html(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = getWebviewHtmlSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.UiService/openUrl" => {
                    #[allow(non_camel_case_types)]
                    struct openUrlSvc<T: UiService>(pub Arc<T>);
                    impl<T: UiService> tonic::server::UnaryService<super::StringRequest>
                    for openUrlSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UiService>::open_url(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = openUrlSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.UiService/openWalkthrough" => {
                    #[allow(non_camel_case_types)]
                    struct openWalkthroughSvc<T: UiService>(pub Arc<T>);
                    impl<T: UiService> tonic::server::UnaryService<super::EmptyRequest>
                    for openWalkthroughSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as UiService>::open_walkthrough(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = openWalkthroughSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for UiServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "cline.UiService";
    impl<T> tonic::server::NamedService for UiServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct State {
    #[prost(string, tag = "1")]
    pub state_json: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminalProfiles {
    #[prost(message, repeated, tag = "1")]
    pub profiles: ::prost::alloc::vec::Vec<TerminalProfile>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminalProfile {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TerminalProfileUpdateResponse {
    #[prost(int32, tag = "1")]
    pub closed_count: i32,
    #[prost(int32, tag = "2")]
    pub busy_terminals_count: i32,
    #[prost(bool, tag = "3")]
    pub has_busy_terminals: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TogglePlanActModeRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(enumeration = "PlanActMode", tag = "2")]
    pub mode: i32,
    #[prost(message, optional, tag = "3")]
    pub chat_content: ::core::option::Option<ChatContent>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChatContent {
    #[prost(string, optional, tag = "1")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub images: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub files: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResetStateRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(bool, optional, tag = "2")]
    pub global: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutoApprovalSettingsRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(int32, tag = "2")]
    pub version: i32,
    #[prost(bool, tag = "3")]
    pub enabled: bool,
    #[prost(message, optional, tag = "4")]
    pub actions: ::core::option::Option<auto_approval_settings_request::Actions>,
    #[prost(int32, tag = "5")]
    pub max_requests: i32,
    #[prost(bool, tag = "6")]
    pub enable_notifications: bool,
    #[prost(string, repeated, tag = "7")]
    pub favorites: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `AutoApprovalSettingsRequest`.
pub mod auto_approval_settings_request {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Actions {
        #[prost(bool, tag = "1")]
        pub read_files: bool,
        #[prost(bool, tag = "2")]
        pub read_files_externally: bool,
        #[prost(bool, tag = "3")]
        pub edit_files: bool,
        #[prost(bool, tag = "4")]
        pub edit_files_externally: bool,
        #[prost(bool, tag = "5")]
        pub execute_safe_commands: bool,
        #[prost(bool, tag = "6")]
        pub execute_all_commands: bool,
        #[prost(bool, tag = "7")]
        pub use_browser: bool,
        #[prost(bool, tag = "8")]
        pub use_mcp: bool,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TelemetrySettingRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(enumeration = "TelemetrySettingEnum", tag = "2")]
    pub setting: i32,
}
/// Message for updating settings
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSettingsRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(message, optional, tag = "2")]
    pub api_configuration: ::core::option::Option<ApiConfiguration>,
    #[prost(string, optional, tag = "3")]
    pub telemetry_setting: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "4")]
    pub plan_act_separate_models_setting: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "5")]
    pub enable_checkpoints_setting: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "6")]
    pub mcp_marketplace_enabled: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "8")]
    pub shell_integration_timeout: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "9")]
    pub terminal_reuse_enabled: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "10")]
    pub mcp_responses_collapsed: ::core::option::Option<bool>,
    #[prost(enumeration = "McpDisplayMode", optional, tag = "11")]
    pub mcp_display_mode: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "12")]
    pub terminal_output_line_limit: ::core::option::Option<i32>,
    #[prost(enumeration = "PlanActMode", optional, tag = "13")]
    pub mode: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "14")]
    pub preferred_language: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "OpenaiReasoningEffort", optional, tag = "15")]
    pub openai_reasoning_effort: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "16")]
    pub strict_plan_mode_enabled: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "17")]
    pub focus_chain_settings: ::core::option::Option<FocusChainSettings>,
}
/// Complete API Configuration message
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApiConfiguration {
    /// Global configuration fields (not mode-specific)
    ///
    /// anthropic
    #[prost(string, optional, tag = "1")]
    pub api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub cline_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub ulid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub lite_llm_base_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub lite_llm_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "6")]
    pub lite_llm_use_prompt_cache: ::core::option::Option<bool>,
    /// JSON string
    #[prost(string, optional, tag = "7")]
    pub openai_headers: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "8")]
    pub anthropic_base_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "9")]
    pub openrouter_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "10")]
    pub openrouter_provider_sorting: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "11")]
    pub aws_access_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "12")]
    pub aws_secret_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "13")]
    pub aws_session_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "14")]
    pub aws_region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "15")]
    pub aws_use_cross_region_inference: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "16")]
    pub aws_bedrock_use_prompt_cache: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "17")]
    pub aws_use_profile: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "18")]
    pub aws_profile: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19")]
    pub aws_bedrock_endpoint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "20")]
    pub claude_code_path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "21")]
    pub vertex_project_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "22")]
    pub vertex_region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "23")]
    pub openai_base_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "24")]
    pub openai_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "25")]
    pub ollama_base_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "26")]
    pub ollama_api_options_ctx_num: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "27")]
    pub lm_studio_base_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "28")]
    pub gemini_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "29")]
    pub gemini_base_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30")]
    pub openai_native_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "31")]
    pub deep_seek_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "32")]
    pub requesty_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "33")]
    pub requesty_base_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "34")]
    pub together_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "35")]
    pub fireworks_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "36")]
    pub fireworks_model_max_completion_tokens: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "37")]
    pub fireworks_model_max_tokens: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "38")]
    pub qwen_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "39")]
    pub doubao_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "40")]
    pub mistral_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "41")]
    pub azure_api_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "42")]
    pub qwen_api_line: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "43")]
    pub nebius_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "44")]
    pub asksage_api_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "45")]
    pub asksage_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "46")]
    pub xai_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "47")]
    pub sambanova_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "48")]
    pub cerebras_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "49")]
    pub request_timeout_ms: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "50")]
    pub sap_ai_core_client_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "51")]
    pub sap_ai_core_client_secret: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "52")]
    pub sap_ai_resource_group: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "53")]
    pub sap_ai_core_token_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "54")]
    pub sap_ai_core_base_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "55")]
    pub moonshot_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "56")]
    pub moonshot_api_line: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "57")]
    pub huawei_cloud_maas_api_key: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "58")]
    pub ollama_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "59")]
    pub zai_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "60")]
    pub zai_api_line: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "61")]
    pub lm_studio_max_tokens: ::core::option::Option<::prost::alloc::string::String>,
    /// Plan mode configurations
    #[prost(string, optional, tag = "100")]
    pub plan_mode_api_provider: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "101")]
    pub plan_mode_api_model_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "102")]
    pub plan_mode_thinking_budget_tokens: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "103")]
    pub plan_mode_reasoning_effort: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// JSON string
    #[prost(string, optional, tag = "104")]
    pub plan_mode_vscode_lm_model_selector: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(bool, optional, tag = "105")]
    pub plan_mode_aws_bedrock_custom_selected: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "106")]
    pub plan_mode_aws_bedrock_custom_model_base_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "107")]
    pub plan_mode_openrouter_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// JSON string
    #[prost(string, optional, tag = "108")]
    pub plan_mode_openrouter_model_info: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "109")]
    pub plan_mode_openai_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// JSON string
    #[prost(string, optional, tag = "110")]
    pub plan_mode_openai_model_info: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "111")]
    pub plan_mode_ollama_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "112")]
    pub plan_mode_lm_studio_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "113")]
    pub plan_mode_lite_llm_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// JSON string
    #[prost(string, optional, tag = "114")]
    pub plan_mode_lite_llm_model_info: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "115")]
    pub plan_mode_requesty_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// JSON string
    #[prost(string, optional, tag = "116")]
    pub plan_mode_requesty_model_info: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "117")]
    pub plan_mode_together_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "118")]
    pub plan_mode_fireworks_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "119")]
    pub plan_mode_sap_ai_core_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "120")]
    pub plan_mode_huawei_cloud_maas_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "121")]
    pub plan_mode_huawei_cloud_maas_model_info: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// Act mode configurations
    #[prost(string, optional, tag = "200")]
    pub act_mode_api_provider: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "201")]
    pub act_mode_api_model_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "202")]
    pub act_mode_thinking_budget_tokens: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "203")]
    pub act_mode_reasoning_effort: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// JSON string
    #[prost(string, optional, tag = "204")]
    pub act_mode_vscode_lm_model_selector: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(bool, optional, tag = "205")]
    pub act_mode_aws_bedrock_custom_selected: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "206")]
    pub act_mode_aws_bedrock_custom_model_base_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "207")]
    pub act_mode_openrouter_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// JSON string
    #[prost(string, optional, tag = "208")]
    pub act_mode_openrouter_model_info: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "209")]
    pub act_mode_openai_model_id: ::core::option::Option<::prost::alloc::string::String>,
    /// JSON string
    #[prost(string, optional, tag = "210")]
    pub act_mode_openai_model_info: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "211")]
    pub act_mode_ollama_model_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "212")]
    pub act_mode_lm_studio_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "213")]
    pub act_mode_lite_llm_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// JSON string
    #[prost(string, optional, tag = "214")]
    pub act_mode_lite_llm_model_info: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "215")]
    pub act_mode_requesty_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// JSON string
    #[prost(string, optional, tag = "216")]
    pub act_mode_requesty_model_info: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "217")]
    pub act_mode_together_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "218")]
    pub act_mode_fireworks_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "219")]
    pub act_mode_sap_ai_core_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "220")]
    pub act_mode_huawei_cloud_maas_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "221")]
    pub act_mode_huawei_cloud_maas_model_info: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// Favorited model IDs
    #[prost(string, repeated, tag = "300")]
    pub favorited_model_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Extension fields for Bedrock Api Keys
    #[prost(string, optional, tag = "301")]
    pub aws_authentication: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "302")]
    pub aws_bedrock_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "303")]
    pub cline_account_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateTerminalConnectionTimeoutRequest {
    #[prost(int32, optional, tag = "1")]
    pub timeout_ms: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FocusChainSettings {
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    #[prost(int32, tag = "2")]
    pub remind_cline_interval: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateTerminalConnectionTimeoutResponse {
    #[prost(int32, optional, tag = "1")]
    pub timeout_ms: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PlanActMode {
    Plan = 0,
    Act = 1,
}
impl PlanActMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Plan => "PLAN",
            Self::Act => "ACT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PLAN" => Some(Self::Plan),
            "ACT" => Some(Self::Act),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OpenaiReasoningEffort {
    Low = 0,
    Medium = 1,
    High = 2,
}
impl OpenaiReasoningEffort {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Low => "LOW",
            Self::Medium => "MEDIUM",
            Self::High => "HIGH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LOW" => Some(Self::Low),
            "MEDIUM" => Some(Self::Medium),
            "HIGH" => Some(Self::High),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum McpDisplayMode {
    Rich = 0,
    Plain = 1,
    Markdown = 2,
}
impl McpDisplayMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Rich => "RICH",
            Self::Plain => "PLAIN",
            Self::Markdown => "MARKDOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RICH" => Some(Self::Rich),
            "PLAIN" => Some(Self::Plain),
            "MARKDOWN" => Some(Self::Markdown),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TelemetrySettingEnum {
    Unset = 0,
    Enabled = 1,
    Disabled = 2,
}
impl TelemetrySettingEnum {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unset => "UNSET",
            Self::Enabled => "ENABLED",
            Self::Disabled => "DISABLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSET" => Some(Self::Unset),
            "ENABLED" => Some(Self::Enabled),
            "DISABLED" => Some(Self::Disabled),
            _ => None,
        }
    }
}
/// Generated server implementations.
pub mod state_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with StateServiceServer.
    #[async_trait]
    pub trait StateService: std::marker::Send + std::marker::Sync + 'static {
        async fn get_latest_state(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<tonic::Response<super::State>, tonic::Status>;
        async fn update_terminal_connection_timeout(
            &self,
            request: tonic::Request<super::UpdateTerminalConnectionTimeoutRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateTerminalConnectionTimeoutResponse>,
            tonic::Status,
        >;
        async fn update_terminal_reuse_enabled(
            &self,
            request: tonic::Request<super::BooleanRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        async fn update_default_terminal_profile(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TerminalProfileUpdateResponse>,
            tonic::Status,
        >;
        async fn get_available_terminal_profiles(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TerminalProfiles>,
            tonic::Status,
        >;
        /// Server streaming response type for the subscribeToState method.
        type subscribeToStateStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::State, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        async fn subscribe_to_state(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::subscribeToStateStream>,
            tonic::Status,
        >;
        async fn toggle_favorite_model(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        async fn reset_state(
            &self,
            request: tonic::Request<super::ResetStateRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        async fn toggle_plan_act_mode_proto(
            &self,
            request: tonic::Request<super::TogglePlanActModeRequest>,
        ) -> std::result::Result<tonic::Response<super::Boolean>, tonic::Status>;
        async fn update_auto_approval_settings(
            &self,
            request: tonic::Request<super::AutoApprovalSettingsRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        async fn update_settings(
            &self,
            request: tonic::Request<super::UpdateSettingsRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        async fn update_telemetry_setting(
            &self,
            request: tonic::Request<super::TelemetrySettingRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        async fn set_welcome_view_completed(
            &self,
            request: tonic::Request<super::BooleanRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
    }
    #[derive(Debug)]
    pub struct StateServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> StateServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for StateServiceServer<T>
    where
        T: StateService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/cline.StateService/getLatestState" => {
                    #[allow(non_camel_case_types)]
                    struct getLatestStateSvc<T: StateService>(pub Arc<T>);
                    impl<
                        T: StateService,
                    > tonic::server::UnaryService<super::EmptyRequest>
                    for getLatestStateSvc<T> {
                        type Response = super::State;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StateService>::get_latest_state(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = getLatestStateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.StateService/updateTerminalConnectionTimeout" => {
                    #[allow(non_camel_case_types)]
                    struct updateTerminalConnectionTimeoutSvc<T: StateService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: StateService,
                    > tonic::server::UnaryService<
                        super::UpdateTerminalConnectionTimeoutRequest,
                    > for updateTerminalConnectionTimeoutSvc<T> {
                        type Response = super::UpdateTerminalConnectionTimeoutResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::UpdateTerminalConnectionTimeoutRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StateService>::update_terminal_connection_timeout(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = updateTerminalConnectionTimeoutSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.StateService/updateTerminalReuseEnabled" => {
                    #[allow(non_camel_case_types)]
                    struct updateTerminalReuseEnabledSvc<T: StateService>(pub Arc<T>);
                    impl<
                        T: StateService,
                    > tonic::server::UnaryService<super::BooleanRequest>
                    for updateTerminalReuseEnabledSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BooleanRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StateService>::update_terminal_reuse_enabled(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = updateTerminalReuseEnabledSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.StateService/updateDefaultTerminalProfile" => {
                    #[allow(non_camel_case_types)]
                    struct updateDefaultTerminalProfileSvc<T: StateService>(pub Arc<T>);
                    impl<
                        T: StateService,
                    > tonic::server::UnaryService<super::StringRequest>
                    for updateDefaultTerminalProfileSvc<T> {
                        type Response = super::TerminalProfileUpdateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StateService>::update_default_terminal_profile(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = updateDefaultTerminalProfileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.StateService/getAvailableTerminalProfiles" => {
                    #[allow(non_camel_case_types)]
                    struct getAvailableTerminalProfilesSvc<T: StateService>(pub Arc<T>);
                    impl<
                        T: StateService,
                    > tonic::server::UnaryService<super::EmptyRequest>
                    for getAvailableTerminalProfilesSvc<T> {
                        type Response = super::TerminalProfiles;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StateService>::get_available_terminal_profiles(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = getAvailableTerminalProfilesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.StateService/subscribeToState" => {
                    #[allow(non_camel_case_types)]
                    struct subscribeToStateSvc<T: StateService>(pub Arc<T>);
                    impl<
                        T: StateService,
                    > tonic::server::ServerStreamingService<super::EmptyRequest>
                    for subscribeToStateSvc<T> {
                        type Response = super::State;
                        type ResponseStream = T::subscribeToStateStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StateService>::subscribe_to_state(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = subscribeToStateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.StateService/toggleFavoriteModel" => {
                    #[allow(non_camel_case_types)]
                    struct toggleFavoriteModelSvc<T: StateService>(pub Arc<T>);
                    impl<
                        T: StateService,
                    > tonic::server::UnaryService<super::StringRequest>
                    for toggleFavoriteModelSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StateService>::toggle_favorite_model(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = toggleFavoriteModelSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.StateService/resetState" => {
                    #[allow(non_camel_case_types)]
                    struct resetStateSvc<T: StateService>(pub Arc<T>);
                    impl<
                        T: StateService,
                    > tonic::server::UnaryService<super::ResetStateRequest>
                    for resetStateSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ResetStateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StateService>::reset_state(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = resetStateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.StateService/togglePlanActModeProto" => {
                    #[allow(non_camel_case_types)]
                    struct togglePlanActModeProtoSvc<T: StateService>(pub Arc<T>);
                    impl<
                        T: StateService,
                    > tonic::server::UnaryService<super::TogglePlanActModeRequest>
                    for togglePlanActModeProtoSvc<T> {
                        type Response = super::Boolean;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TogglePlanActModeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StateService>::toggle_plan_act_mode_proto(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = togglePlanActModeProtoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.StateService/updateAutoApprovalSettings" => {
                    #[allow(non_camel_case_types)]
                    struct updateAutoApprovalSettingsSvc<T: StateService>(pub Arc<T>);
                    impl<
                        T: StateService,
                    > tonic::server::UnaryService<super::AutoApprovalSettingsRequest>
                    for updateAutoApprovalSettingsSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AutoApprovalSettingsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StateService>::update_auto_approval_settings(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = updateAutoApprovalSettingsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.StateService/updateSettings" => {
                    #[allow(non_camel_case_types)]
                    struct updateSettingsSvc<T: StateService>(pub Arc<T>);
                    impl<
                        T: StateService,
                    > tonic::server::UnaryService<super::UpdateSettingsRequest>
                    for updateSettingsSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateSettingsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StateService>::update_settings(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = updateSettingsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.StateService/updateTelemetrySetting" => {
                    #[allow(non_camel_case_types)]
                    struct updateTelemetrySettingSvc<T: StateService>(pub Arc<T>);
                    impl<
                        T: StateService,
                    > tonic::server::UnaryService<super::TelemetrySettingRequest>
                    for updateTelemetrySettingSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::TelemetrySettingRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StateService>::update_telemetry_setting(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = updateTelemetrySettingSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.StateService/setWelcomeViewCompleted" => {
                    #[allow(non_camel_case_types)]
                    struct setWelcomeViewCompletedSvc<T: StateService>(pub Arc<T>);
                    impl<
                        T: StateService,
                    > tonic::server::UnaryService<super::BooleanRequest>
                    for setWelcomeViewCompletedSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BooleanRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as StateService>::set_welcome_view_completed(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = setWelcomeViewCompletedSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for StateServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "cline.StateService";
    impl<T> tonic::server::NamedService for StateServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// List of VS Code LM models
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VsCodeLmModelsArray {
    #[prost(message, repeated, tag = "1")]
    pub models: ::prost::alloc::vec::Vec<LanguageModelChatSelector>,
}
/// Structure representing a language model chat selector
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LanguageModelChatSelector {
    #[prost(string, optional, tag = "1")]
    pub vendor: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub family: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Price tier for tiered pricing models
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PriceTier {
    /// Upper limit (inclusive) of input tokens for this price
    #[prost(int32, tag = "1")]
    pub token_limit: i32,
    /// Price per million tokens for this tier
    #[prost(double, tag = "2")]
    pub price: f64,
}
/// Thinking configuration for models that support thinking/reasoning
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThinkingConfig {
    /// Max allowed thinking budget tokens
    #[prost(int32, optional, tag = "1")]
    pub max_budget: ::core::option::Option<i32>,
    /// Output price per million tokens when budget > 0
    #[prost(double, optional, tag = "2")]
    pub output_price: ::core::option::Option<f64>,
    /// Optional: Tiered output price when budget > 0
    #[prost(message, repeated, tag = "3")]
    pub output_price_tiers: ::prost::alloc::vec::Vec<PriceTier>,
}
/// Model tier for tiered pricing structures
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ModelTier {
    #[prost(int32, tag = "1")]
    pub context_window: i32,
    #[prost(double, optional, tag = "2")]
    pub input_price: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "3")]
    pub output_price: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "4")]
    pub cache_writes_price: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "5")]
    pub cache_reads_price: ::core::option::Option<f64>,
}
/// For OpenRouterCompatibleModelInfo structure in OpenRouterModels
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenRouterModelInfo {
    #[prost(int32, optional, tag = "1")]
    pub max_tokens: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub context_window: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub supports_images: ::core::option::Option<bool>,
    #[prost(bool, tag = "4")]
    pub supports_prompt_cache: bool,
    #[prost(double, optional, tag = "5")]
    pub input_price: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "6")]
    pub output_price: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "7")]
    pub cache_writes_price: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "8")]
    pub cache_reads_price: ::core::option::Option<f64>,
    #[prost(string, optional, tag = "9")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "10")]
    pub thinking_config: ::core::option::Option<ThinkingConfig>,
    #[prost(bool, optional, tag = "11")]
    pub supports_global_endpoint: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "12")]
    pub tiers: ::prost::alloc::vec::Vec<ModelTier>,
}
/// Shared response message for model information
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenRouterCompatibleModelInfo {
    #[prost(map = "string, message", tag = "1")]
    pub models: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        OpenRouterModelInfo,
    >,
}
/// Request for fetching OpenAI models
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenAiModelsRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(string, tag = "2")]
    pub base_url: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub api_key: ::prost::alloc::string::String,
}
/// Request for updating API configuration
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateApiConfigurationRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(message, optional, tag = "2")]
    pub api_configuration: ::core::option::Option<ModelsApiConfiguration>,
}
/// Model info for OpenAI-compatible models
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenAiCompatibleModelInfo {
    #[prost(int32, optional, tag = "1")]
    pub max_tokens: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub context_window: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub supports_images: ::core::option::Option<bool>,
    #[prost(bool, tag = "4")]
    pub supports_prompt_cache: bool,
    #[prost(double, optional, tag = "5")]
    pub input_price: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "6")]
    pub output_price: ::core::option::Option<f64>,
    #[prost(message, optional, tag = "7")]
    pub thinking_config: ::core::option::Option<ThinkingConfig>,
    #[prost(bool, optional, tag = "8")]
    pub supports_global_endpoint: ::core::option::Option<bool>,
    #[prost(double, optional, tag = "9")]
    pub cache_writes_price: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "10")]
    pub cache_reads_price: ::core::option::Option<f64>,
    #[prost(string, optional, tag = "11")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "12")]
    pub tiers: ::prost::alloc::vec::Vec<ModelTier>,
    #[prost(double, optional, tag = "13")]
    pub temperature: ::core::option::Option<f64>,
    #[prost(bool, optional, tag = "14")]
    pub is_r1_format_required: ::core::option::Option<bool>,
}
/// Model info for LiteLLM models
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LiteLlmModelInfo {
    #[prost(int32, optional, tag = "1")]
    pub max_tokens: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "2")]
    pub context_window: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "3")]
    pub supports_images: ::core::option::Option<bool>,
    #[prost(bool, tag = "4")]
    pub supports_prompt_cache: bool,
    #[prost(double, optional, tag = "5")]
    pub input_price: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "6")]
    pub output_price: ::core::option::Option<f64>,
    #[prost(message, optional, tag = "7")]
    pub thinking_config: ::core::option::Option<ThinkingConfig>,
    #[prost(bool, optional, tag = "8")]
    pub supports_global_endpoint: ::core::option::Option<bool>,
    #[prost(double, optional, tag = "9")]
    pub cache_writes_price: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "10")]
    pub cache_reads_price: ::core::option::Option<f64>,
    #[prost(string, optional, tag = "11")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "12")]
    pub tiers: ::prost::alloc::vec::Vec<ModelTier>,
    #[prost(double, optional, tag = "13")]
    pub temperature: ::core::option::Option<f64>,
}
/// Main ApiConfiguration message
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ModelsApiConfiguration {
    /// Global configuration fields (not mode-specific)
    #[prost(string, optional, tag = "1")]
    pub api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub cline_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub ulid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub lite_llm_base_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub lite_llm_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "6")]
    pub lite_llm_use_prompt_cache: ::core::option::Option<bool>,
    #[prost(map = "string, string", tag = "7")]
    pub open_ai_headers: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "8")]
    pub anthropic_base_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "9")]
    pub open_router_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "10")]
    pub open_router_provider_sorting: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "11")]
    pub aws_access_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "12")]
    pub aws_secret_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "13")]
    pub aws_session_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "14")]
    pub aws_region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "15")]
    pub aws_use_cross_region_inference: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "16")]
    pub aws_bedrock_use_prompt_cache: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "17")]
    pub aws_use_profile: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "18")]
    pub aws_profile: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19")]
    pub aws_bedrock_endpoint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "20")]
    pub claude_code_path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "21")]
    pub vertex_project_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "22")]
    pub vertex_region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "23")]
    pub open_ai_base_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "24")]
    pub open_ai_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "25")]
    pub ollama_base_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "26")]
    pub ollama_api_options_ctx_num: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "27")]
    pub lm_studio_base_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "28")]
    pub gemini_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "29")]
    pub gemini_base_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30")]
    pub open_ai_native_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "31")]
    pub deep_seek_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "32")]
    pub requesty_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "33")]
    pub requesty_base_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "34")]
    pub together_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "35")]
    pub fireworks_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "36")]
    pub fireworks_model_max_completion_tokens: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "37")]
    pub fireworks_model_max_tokens: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "38")]
    pub qwen_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "39")]
    pub doubao_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "40")]
    pub mistral_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "41")]
    pub azure_api_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "42")]
    pub qwen_api_line: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "43")]
    pub nebius_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "44")]
    pub asksage_api_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "45")]
    pub asksage_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "46")]
    pub xai_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "47")]
    pub sambanova_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "48")]
    pub cerebras_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "49")]
    pub request_timeout_ms: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "50")]
    pub sap_ai_core_client_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "51")]
    pub sap_ai_core_client_secret: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "52")]
    pub sap_ai_resource_group: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "53")]
    pub sap_ai_core_token_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "54")]
    pub sap_ai_core_base_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "55")]
    pub moonshot_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "56")]
    pub moonshot_api_line: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "57")]
    pub aws_authentication: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "58")]
    pub aws_bedrock_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "59")]
    pub cline_account_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "60")]
    pub groq_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "61")]
    pub hugging_face_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "62")]
    pub huawei_cloud_maas_api_key: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "63")]
    pub baseten_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "64")]
    pub ollama_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "65")]
    pub zai_api_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "66")]
    pub zai_api_line: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "67")]
    pub lm_studio_max_tokens: ::core::option::Option<::prost::alloc::string::String>,
    /// Plan mode configurations
    #[prost(enumeration = "ApiProvider", optional, tag = "100")]
    pub plan_mode_api_provider: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "101")]
    pub plan_mode_api_model_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "102")]
    pub plan_mode_thinking_budget_tokens: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "103")]
    pub plan_mode_reasoning_effort: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "104")]
    pub plan_mode_vs_code_lm_model_selector: ::core::option::Option<
        LanguageModelChatSelector,
    >,
    #[prost(bool, optional, tag = "105")]
    pub plan_mode_aws_bedrock_custom_selected: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "106")]
    pub plan_mode_aws_bedrock_custom_model_base_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "107")]
    pub plan_mode_open_router_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "108")]
    pub plan_mode_open_router_model_info: ::core::option::Option<OpenRouterModelInfo>,
    #[prost(string, optional, tag = "109")]
    pub plan_mode_open_ai_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "110")]
    pub plan_mode_open_ai_model_info: ::core::option::Option<OpenAiCompatibleModelInfo>,
    #[prost(string, optional, tag = "111")]
    pub plan_mode_ollama_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "112")]
    pub plan_mode_lm_studio_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "113")]
    pub plan_mode_lite_llm_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "114")]
    pub plan_mode_lite_llm_model_info: ::core::option::Option<LiteLlmModelInfo>,
    #[prost(string, optional, tag = "115")]
    pub plan_mode_requesty_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "116")]
    pub plan_mode_requesty_model_info: ::core::option::Option<OpenRouterModelInfo>,
    #[prost(string, optional, tag = "117")]
    pub plan_mode_together_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "118")]
    pub plan_mode_fireworks_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "119")]
    pub plan_mode_sap_ai_core_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "120")]
    pub plan_mode_groq_model_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "121")]
    pub plan_mode_groq_model_info: ::core::option::Option<OpenRouterModelInfo>,
    #[prost(string, optional, tag = "122")]
    pub plan_mode_hugging_face_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "123")]
    pub plan_mode_hugging_face_model_info: ::core::option::Option<OpenRouterModelInfo>,
    #[prost(string, optional, tag = "124")]
    pub plan_mode_huawei_cloud_maas_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "125")]
    pub plan_mode_huawei_cloud_maas_model_info: ::core::option::Option<
        OpenRouterModelInfo,
    >,
    #[prost(string, optional, tag = "126")]
    pub plan_mode_baseten_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "127")]
    pub plan_mode_baseten_model_info: ::core::option::Option<OpenRouterModelInfo>,
    /// Act mode configurations
    #[prost(enumeration = "ApiProvider", optional, tag = "200")]
    pub act_mode_api_provider: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "201")]
    pub act_mode_api_model_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "202")]
    pub act_mode_thinking_budget_tokens: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "203")]
    pub act_mode_reasoning_effort: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "204")]
    pub act_mode_vs_code_lm_model_selector: ::core::option::Option<
        LanguageModelChatSelector,
    >,
    #[prost(bool, optional, tag = "205")]
    pub act_mode_aws_bedrock_custom_selected: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "206")]
    pub act_mode_aws_bedrock_custom_model_base_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "207")]
    pub act_mode_open_router_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "208")]
    pub act_mode_open_router_model_info: ::core::option::Option<OpenRouterModelInfo>,
    #[prost(string, optional, tag = "209")]
    pub act_mode_open_ai_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "210")]
    pub act_mode_open_ai_model_info: ::core::option::Option<OpenAiCompatibleModelInfo>,
    #[prost(string, optional, tag = "211")]
    pub act_mode_ollama_model_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "212")]
    pub act_mode_lm_studio_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "213")]
    pub act_mode_lite_llm_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "214")]
    pub act_mode_lite_llm_model_info: ::core::option::Option<LiteLlmModelInfo>,
    #[prost(string, optional, tag = "215")]
    pub act_mode_requesty_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "216")]
    pub act_mode_requesty_model_info: ::core::option::Option<OpenRouterModelInfo>,
    #[prost(string, optional, tag = "217")]
    pub act_mode_together_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "218")]
    pub act_mode_fireworks_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "219")]
    pub act_mode_sap_ai_core_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "220")]
    pub act_mode_groq_model_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "221")]
    pub act_mode_groq_model_info: ::core::option::Option<OpenRouterModelInfo>,
    #[prost(string, optional, tag = "222")]
    pub act_mode_hugging_face_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "223")]
    pub act_mode_hugging_face_model_info: ::core::option::Option<OpenRouterModelInfo>,
    #[prost(string, optional, tag = "224")]
    pub act_mode_huawei_cloud_maas_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "225")]
    pub act_mode_huawei_cloud_maas_model_info: ::core::option::Option<
        OpenRouterModelInfo,
    >,
    #[prost(string, optional, tag = "226")]
    pub act_mode_baseten_model_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "227")]
    pub act_mode_baseten_model_info: ::core::option::Option<OpenRouterModelInfo>,
    #[prost(string, repeated, tag = "300")]
    pub favorited_model_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// API Provider enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ApiProvider {
    Anthropic = 0,
    Openrouter = 1,
    Bedrock = 2,
    Vertex = 3,
    Openai = 4,
    Ollama = 5,
    Lmstudio = 6,
    Gemini = 7,
    OpenaiNative = 8,
    Requesty = 9,
    Together = 10,
    Deepseek = 11,
    Qwen = 12,
    Doubao = 13,
    Mistral = 14,
    VscodeLm = 15,
    Cline = 16,
    Litellm = 17,
    Nebius = 18,
    Fireworks = 19,
    Asksage = 20,
    Xai = 21,
    Sambanova = 22,
    Cerebras = 23,
    Groq = 24,
    Sapaicore = 25,
    ClaudeCode = 26,
    Moonshot = 27,
    Huggingface = 28,
    HuaweiCloudMaas = 29,
    Baseten = 30,
    Zai = 31,
}
impl ApiProvider {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Anthropic => "ANTHROPIC",
            Self::Openrouter => "OPENROUTER",
            Self::Bedrock => "BEDROCK",
            Self::Vertex => "VERTEX",
            Self::Openai => "OPENAI",
            Self::Ollama => "OLLAMA",
            Self::Lmstudio => "LMSTUDIO",
            Self::Gemini => "GEMINI",
            Self::OpenaiNative => "OPENAI_NATIVE",
            Self::Requesty => "REQUESTY",
            Self::Together => "TOGETHER",
            Self::Deepseek => "DEEPSEEK",
            Self::Qwen => "QWEN",
            Self::Doubao => "DOUBAO",
            Self::Mistral => "MISTRAL",
            Self::VscodeLm => "VSCODE_LM",
            Self::Cline => "CLINE",
            Self::Litellm => "LITELLM",
            Self::Nebius => "NEBIUS",
            Self::Fireworks => "FIREWORKS",
            Self::Asksage => "ASKSAGE",
            Self::Xai => "XAI",
            Self::Sambanova => "SAMBANOVA",
            Self::Cerebras => "CEREBRAS",
            Self::Groq => "GROQ",
            Self::Sapaicore => "SAPAICORE",
            Self::ClaudeCode => "CLAUDE_CODE",
            Self::Moonshot => "MOONSHOT",
            Self::Huggingface => "HUGGINGFACE",
            Self::HuaweiCloudMaas => "HUAWEI_CLOUD_MAAS",
            Self::Baseten => "BASETEN",
            Self::Zai => "ZAI",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ANTHROPIC" => Some(Self::Anthropic),
            "OPENROUTER" => Some(Self::Openrouter),
            "BEDROCK" => Some(Self::Bedrock),
            "VERTEX" => Some(Self::Vertex),
            "OPENAI" => Some(Self::Openai),
            "OLLAMA" => Some(Self::Ollama),
            "LMSTUDIO" => Some(Self::Lmstudio),
            "GEMINI" => Some(Self::Gemini),
            "OPENAI_NATIVE" => Some(Self::OpenaiNative),
            "REQUESTY" => Some(Self::Requesty),
            "TOGETHER" => Some(Self::Together),
            "DEEPSEEK" => Some(Self::Deepseek),
            "QWEN" => Some(Self::Qwen),
            "DOUBAO" => Some(Self::Doubao),
            "MISTRAL" => Some(Self::Mistral),
            "VSCODE_LM" => Some(Self::VscodeLm),
            "CLINE" => Some(Self::Cline),
            "LITELLM" => Some(Self::Litellm),
            "NEBIUS" => Some(Self::Nebius),
            "FIREWORKS" => Some(Self::Fireworks),
            "ASKSAGE" => Some(Self::Asksage),
            "XAI" => Some(Self::Xai),
            "SAMBANOVA" => Some(Self::Sambanova),
            "CEREBRAS" => Some(Self::Cerebras),
            "GROQ" => Some(Self::Groq),
            "SAPAICORE" => Some(Self::Sapaicore),
            "CLAUDE_CODE" => Some(Self::ClaudeCode),
            "MOONSHOT" => Some(Self::Moonshot),
            "HUGGINGFACE" => Some(Self::Huggingface),
            "HUAWEI_CLOUD_MAAS" => Some(Self::HuaweiCloudMaas),
            "BASETEN" => Some(Self::Baseten),
            "ZAI" => Some(Self::Zai),
            _ => None,
        }
    }
}
/// Generated server implementations.
pub mod models_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ModelsServiceServer.
    #[async_trait]
    pub trait ModelsService: std::marker::Send + std::marker::Sync + 'static {
        /// Fetches available models from Ollama
        async fn get_ollama_models(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::StringArray>, tonic::Status>;
        /// Fetches available models from LM Studio
        async fn get_lm_studio_models(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::StringArray>, tonic::Status>;
        /// Fetches available models from VS Code LM API
        async fn get_vs_code_lm_models(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::VsCodeLmModelsArray>,
            tonic::Status,
        >;
        /// Refreshes and returns OpenRouter models
        async fn refresh_open_router_models(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OpenRouterCompatibleModelInfo>,
            tonic::Status,
        >;
        /// Refreshes and returns Hugging Face models
        async fn refresh_hugging_face_models(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OpenRouterCompatibleModelInfo>,
            tonic::Status,
        >;
        /// Refreshes and returns OpenAI models
        async fn refresh_open_ai_models(
            &self,
            request: tonic::Request<super::OpenAiModelsRequest>,
        ) -> std::result::Result<tonic::Response<super::StringArray>, tonic::Status>;
        /// Refreshes and returns Requesty models
        async fn refresh_requesty_models(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OpenRouterCompatibleModelInfo>,
            tonic::Status,
        >;
        /// Server streaming response type for the subscribeToOpenRouterModels method.
        type subscribeToOpenRouterModelsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<
                    super::OpenRouterCompatibleModelInfo,
                    tonic::Status,
                >,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to OpenRouter models updates
        async fn subscribe_to_open_router_models(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::subscribeToOpenRouterModelsStream>,
            tonic::Status,
        >;
        /// Updates API configuration
        async fn update_api_configuration_proto(
            &self,
            request: tonic::Request<super::UpdateApiConfigurationRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        /// Refreshes and returns Groq models
        async fn refresh_groq_models(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OpenRouterCompatibleModelInfo>,
            tonic::Status,
        >;
        /// Refreshes and returns Baseten models
        async fn refresh_baseten_models(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OpenRouterCompatibleModelInfo>,
            tonic::Status,
        >;
    }
    /// Service for model-related operations
    #[derive(Debug)]
    pub struct ModelsServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ModelsServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ModelsServiceServer<T>
    where
        T: ModelsService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/cline.ModelsService/getOllamaModels" => {
                    #[allow(non_camel_case_types)]
                    struct getOllamaModelsSvc<T: ModelsService>(pub Arc<T>);
                    impl<
                        T: ModelsService,
                    > tonic::server::UnaryService<super::StringRequest>
                    for getOllamaModelsSvc<T> {
                        type Response = super::StringArray;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ModelsService>::get_ollama_models(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = getOllamaModelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.ModelsService/getLmStudioModels" => {
                    #[allow(non_camel_case_types)]
                    struct getLmStudioModelsSvc<T: ModelsService>(pub Arc<T>);
                    impl<
                        T: ModelsService,
                    > tonic::server::UnaryService<super::StringRequest>
                    for getLmStudioModelsSvc<T> {
                        type Response = super::StringArray;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ModelsService>::get_lm_studio_models(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = getLmStudioModelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.ModelsService/getVsCodeLmModels" => {
                    #[allow(non_camel_case_types)]
                    struct getVsCodeLmModelsSvc<T: ModelsService>(pub Arc<T>);
                    impl<
                        T: ModelsService,
                    > tonic::server::UnaryService<super::EmptyRequest>
                    for getVsCodeLmModelsSvc<T> {
                        type Response = super::VsCodeLmModelsArray;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ModelsService>::get_vs_code_lm_models(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = getVsCodeLmModelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.ModelsService/refreshOpenRouterModels" => {
                    #[allow(non_camel_case_types)]
                    struct refreshOpenRouterModelsSvc<T: ModelsService>(pub Arc<T>);
                    impl<
                        T: ModelsService,
                    > tonic::server::UnaryService<super::EmptyRequest>
                    for refreshOpenRouterModelsSvc<T> {
                        type Response = super::OpenRouterCompatibleModelInfo;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ModelsService>::refresh_open_router_models(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = refreshOpenRouterModelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.ModelsService/refreshHuggingFaceModels" => {
                    #[allow(non_camel_case_types)]
                    struct refreshHuggingFaceModelsSvc<T: ModelsService>(pub Arc<T>);
                    impl<
                        T: ModelsService,
                    > tonic::server::UnaryService<super::EmptyRequest>
                    for refreshHuggingFaceModelsSvc<T> {
                        type Response = super::OpenRouterCompatibleModelInfo;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ModelsService>::refresh_hugging_face_models(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = refreshHuggingFaceModelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.ModelsService/refreshOpenAiModels" => {
                    #[allow(non_camel_case_types)]
                    struct refreshOpenAiModelsSvc<T: ModelsService>(pub Arc<T>);
                    impl<
                        T: ModelsService,
                    > tonic::server::UnaryService<super::OpenAiModelsRequest>
                    for refreshOpenAiModelsSvc<T> {
                        type Response = super::StringArray;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::OpenAiModelsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ModelsService>::refresh_open_ai_models(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = refreshOpenAiModelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.ModelsService/refreshRequestyModels" => {
                    #[allow(non_camel_case_types)]
                    struct refreshRequestyModelsSvc<T: ModelsService>(pub Arc<T>);
                    impl<
                        T: ModelsService,
                    > tonic::server::UnaryService<super::EmptyRequest>
                    for refreshRequestyModelsSvc<T> {
                        type Response = super::OpenRouterCompatibleModelInfo;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ModelsService>::refresh_requesty_models(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = refreshRequestyModelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.ModelsService/subscribeToOpenRouterModels" => {
                    #[allow(non_camel_case_types)]
                    struct subscribeToOpenRouterModelsSvc<T: ModelsService>(pub Arc<T>);
                    impl<
                        T: ModelsService,
                    > tonic::server::ServerStreamingService<super::EmptyRequest>
                    for subscribeToOpenRouterModelsSvc<T> {
                        type Response = super::OpenRouterCompatibleModelInfo;
                        type ResponseStream = T::subscribeToOpenRouterModelsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ModelsService>::subscribe_to_open_router_models(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = subscribeToOpenRouterModelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.ModelsService/updateApiConfigurationProto" => {
                    #[allow(non_camel_case_types)]
                    struct updateApiConfigurationProtoSvc<T: ModelsService>(pub Arc<T>);
                    impl<
                        T: ModelsService,
                    > tonic::server::UnaryService<super::UpdateApiConfigurationRequest>
                    for updateApiConfigurationProtoSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateApiConfigurationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ModelsService>::update_api_configuration_proto(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = updateApiConfigurationProtoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.ModelsService/refreshGroqModels" => {
                    #[allow(non_camel_case_types)]
                    struct refreshGroqModelsSvc<T: ModelsService>(pub Arc<T>);
                    impl<
                        T: ModelsService,
                    > tonic::server::UnaryService<super::EmptyRequest>
                    for refreshGroqModelsSvc<T> {
                        type Response = super::OpenRouterCompatibleModelInfo;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ModelsService>::refresh_groq_models(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = refreshGroqModelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.ModelsService/refreshBasetenModels" => {
                    #[allow(non_camel_case_types)]
                    struct refreshBasetenModelsSvc<T: ModelsService>(pub Arc<T>);
                    impl<
                        T: ModelsService,
                    > tonic::server::UnaryService<super::EmptyRequest>
                    for refreshBasetenModelsSvc<T> {
                        type Response = super::OpenRouterCompatibleModelInfo;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ModelsService>::refresh_baseten_models(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = refreshBasetenModelsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ModelsServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "cline.ModelsService";
    impl<T> tonic::server::NamedService for ModelsServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrowserConnectionInfo {
    #[prost(bool, tag = "1")]
    pub is_connected: bool,
    #[prost(bool, tag = "2")]
    pub is_remote: bool,
    #[prost(string, optional, tag = "3")]
    pub host: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrowserConnection {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3")]
    pub endpoint: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChromePath {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_bundled: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Viewport {
    #[prost(int32, tag = "1")]
    pub width: i32,
    #[prost(int32, tag = "2")]
    pub height: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrowserSettings {
    #[prost(message, optional, tag = "1")]
    pub viewport: ::core::option::Option<Viewport>,
    #[prost(string, optional, tag = "2")]
    pub remote_browser_host: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "3")]
    pub remote_browser_enabled: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "4")]
    pub chrome_executable_path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "5")]
    pub disable_tool_use: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "6")]
    pub custom_args: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBrowserSettingsRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(message, optional, tag = "2")]
    pub viewport: ::core::option::Option<Viewport>,
    #[prost(string, optional, tag = "3")]
    pub remote_browser_host: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "4")]
    pub remote_browser_enabled: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "5")]
    pub chrome_executable_path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "6")]
    pub disable_tool_use: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "7")]
    pub custom_args: ::core::option::Option<::prost::alloc::string::String>,
}
/// Generated server implementations.
pub mod browser_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with BrowserServiceServer.
    #[async_trait]
    pub trait BrowserService: std::marker::Send + std::marker::Sync + 'static {
        async fn get_browser_connection_info(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BrowserConnectionInfo>,
            tonic::Status,
        >;
        async fn test_browser_connection(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BrowserConnection>,
            tonic::Status,
        >;
        async fn discover_browser(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BrowserConnection>,
            tonic::Status,
        >;
        async fn get_detected_chrome_path(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<tonic::Response<super::ChromePath>, tonic::Status>;
        async fn update_browser_settings(
            &self,
            request: tonic::Request<super::UpdateBrowserSettingsRequest>,
        ) -> std::result::Result<tonic::Response<super::Boolean>, tonic::Status>;
        async fn relaunch_chrome_debug_mode(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<tonic::Response<super::String>, tonic::Status>;
    }
    #[derive(Debug)]
    pub struct BrowserServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> BrowserServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for BrowserServiceServer<T>
    where
        T: BrowserService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/cline.BrowserService/getBrowserConnectionInfo" => {
                    #[allow(non_camel_case_types)]
                    struct getBrowserConnectionInfoSvc<T: BrowserService>(pub Arc<T>);
                    impl<
                        T: BrowserService,
                    > tonic::server::UnaryService<super::EmptyRequest>
                    for getBrowserConnectionInfoSvc<T> {
                        type Response = super::BrowserConnectionInfo;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BrowserService>::get_browser_connection_info(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = getBrowserConnectionInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.BrowserService/testBrowserConnection" => {
                    #[allow(non_camel_case_types)]
                    struct testBrowserConnectionSvc<T: BrowserService>(pub Arc<T>);
                    impl<
                        T: BrowserService,
                    > tonic::server::UnaryService<super::StringRequest>
                    for testBrowserConnectionSvc<T> {
                        type Response = super::BrowserConnection;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BrowserService>::test_browser_connection(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = testBrowserConnectionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.BrowserService/discoverBrowser" => {
                    #[allow(non_camel_case_types)]
                    struct discoverBrowserSvc<T: BrowserService>(pub Arc<T>);
                    impl<
                        T: BrowserService,
                    > tonic::server::UnaryService<super::EmptyRequest>
                    for discoverBrowserSvc<T> {
                        type Response = super::BrowserConnection;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BrowserService>::discover_browser(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = discoverBrowserSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.BrowserService/getDetectedChromePath" => {
                    #[allow(non_camel_case_types)]
                    struct getDetectedChromePathSvc<T: BrowserService>(pub Arc<T>);
                    impl<
                        T: BrowserService,
                    > tonic::server::UnaryService<super::EmptyRequest>
                    for getDetectedChromePathSvc<T> {
                        type Response = super::ChromePath;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BrowserService>::get_detected_chrome_path(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = getDetectedChromePathSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.BrowserService/updateBrowserSettings" => {
                    #[allow(non_camel_case_types)]
                    struct updateBrowserSettingsSvc<T: BrowserService>(pub Arc<T>);
                    impl<
                        T: BrowserService,
                    > tonic::server::UnaryService<super::UpdateBrowserSettingsRequest>
                    for updateBrowserSettingsSvc<T> {
                        type Response = super::Boolean;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateBrowserSettingsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BrowserService>::update_browser_settings(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = updateBrowserSettingsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.BrowserService/relaunchChromeDebugMode" => {
                    #[allow(non_camel_case_types)]
                    struct relaunchChromeDebugModeSvc<T: BrowserService>(pub Arc<T>);
                    impl<
                        T: BrowserService,
                    > tonic::server::UnaryService<super::EmptyRequest>
                    for relaunchChromeDebugModeSvc<T> {
                        type Response = super::String;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as BrowserService>::relaunch_chrome_debug_mode(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = relaunchChromeDebugModeSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for BrowserServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "cline.BrowserService";
    impl<T> tonic::server::NamedService for BrowserServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckpointRestoreRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(int64, tag = "2")]
    pub number: i64,
    #[prost(string, tag = "3")]
    pub restore_type: ::prost::alloc::string::String,
    #[prost(int64, optional, tag = "4")]
    pub offset: ::core::option::Option<i64>,
}
/// Generated server implementations.
pub mod checkpoints_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CheckpointsServiceServer.
    #[async_trait]
    pub trait CheckpointsService: std::marker::Send + std::marker::Sync + 'static {
        async fn checkpoint_diff(
            &self,
            request: tonic::Request<super::Int64Request>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        async fn checkpoint_restore(
            &self,
            request: tonic::Request<super::CheckpointRestoreRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
    }
    #[derive(Debug)]
    pub struct CheckpointsServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CheckpointsServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for CheckpointsServiceServer<T>
    where
        T: CheckpointsService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/cline.CheckpointsService/checkpointDiff" => {
                    #[allow(non_camel_case_types)]
                    struct checkpointDiffSvc<T: CheckpointsService>(pub Arc<T>);
                    impl<
                        T: CheckpointsService,
                    > tonic::server::UnaryService<super::Int64Request>
                    for checkpointDiffSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::Int64Request>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CheckpointsService>::checkpoint_diff(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = checkpointDiffSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.CheckpointsService/checkpointRestore" => {
                    #[allow(non_camel_case_types)]
                    struct checkpointRestoreSvc<T: CheckpointsService>(pub Arc<T>);
                    impl<
                        T: CheckpointsService,
                    > tonic::server::UnaryService<super::CheckpointRestoreRequest>
                    for checkpointRestoreSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CheckpointRestoreRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CheckpointsService>::checkpoint_restore(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = checkpointRestoreSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CheckpointsServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "cline.CheckpointsService";
    impl<T> tonic::server::NamedService for CheckpointsServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToggleMcpServerRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(string, tag = "2")]
    pub server_name: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub disabled: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateMcpTimeoutRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(string, tag = "2")]
    pub server_name: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub timeout: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddRemoteMcpServerRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(string, tag = "2")]
    pub server_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub server_url: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToggleToolAutoApproveRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(string, tag = "2")]
    pub server_name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub tool_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "4")]
    pub auto_approve: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct McpTool {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub input_schema: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "4")]
    pub auto_approve: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct McpResource {
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3")]
    pub mime_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct McpResourceTemplate {
    #[prost(string, tag = "1")]
    pub uri_template: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3")]
    pub mime_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct McpServer {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub config: ::prost::alloc::string::String,
    #[prost(enumeration = "McpServerStatus", tag = "3")]
    pub status: i32,
    #[prost(string, optional, tag = "4")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "5")]
    pub tools: ::prost::alloc::vec::Vec<McpTool>,
    #[prost(message, repeated, tag = "6")]
    pub resources: ::prost::alloc::vec::Vec<McpResource>,
    #[prost(message, repeated, tag = "7")]
    pub resource_templates: ::prost::alloc::vec::Vec<McpResourceTemplate>,
    #[prost(bool, optional, tag = "8")]
    pub disabled: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "9")]
    pub timeout: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct McpServers {
    #[prost(message, repeated, tag = "1")]
    pub mcp_servers: ::prost::alloc::vec::Vec<McpServer>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct McpMarketplaceItem {
    #[prost(string, tag = "1")]
    pub mcp_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub github_url: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub author: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub codicon_icon: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub logo_url: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub category: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "9")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "10")]
    pub requires_api_key: bool,
    #[prost(string, optional, tag = "11")]
    pub readme_content: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "12")]
    pub llms_installation_content: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(bool, tag = "13")]
    pub is_recommended: bool,
    #[prost(int32, tag = "14")]
    pub github_stars: i32,
    #[prost(int32, tag = "15")]
    pub download_count: i32,
    #[prost(string, tag = "16")]
    pub created_at: ::prost::alloc::string::String,
    #[prost(string, tag = "17")]
    pub updated_at: ::prost::alloc::string::String,
    #[prost(string, tag = "18")]
    pub last_github_sync: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct McpMarketplaceCatalog {
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<McpMarketplaceItem>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct McpDownloadResponse {
    #[prost(string, tag = "1")]
    pub mcp_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub github_url: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub author: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub readme_content: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub llms_installation_content: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub requires_api_key: bool,
    #[prost(string, optional, tag = "9")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum McpServerStatus {
    /// Protobuf enums (in proto3) must have a zero value defined, which serves as the default if the field isn't explicitly set.
    /// To align with the required nature of the TypeScript type and avoid an unnecessary UNSPECIFIED state, we map one of the existing statuses to this zero value.
    ///
    /// default
    Disconnected = 0,
    Connected = 1,
    Connecting = 2,
}
impl McpServerStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Disconnected => "MCP_SERVER_STATUS_DISCONNECTED",
            Self::Connected => "MCP_SERVER_STATUS_CONNECTED",
            Self::Connecting => "MCP_SERVER_STATUS_CONNECTING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MCP_SERVER_STATUS_DISCONNECTED" => Some(Self::Disconnected),
            "MCP_SERVER_STATUS_CONNECTED" => Some(Self::Connected),
            "MCP_SERVER_STATUS_CONNECTING" => Some(Self::Connecting),
            _ => None,
        }
    }
}
/// Generated server implementations.
pub mod mcp_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with McpServiceServer.
    #[async_trait]
    pub trait McpService: std::marker::Send + std::marker::Sync + 'static {
        async fn toggle_mcp_server(
            &self,
            request: tonic::Request<super::ToggleMcpServerRequest>,
        ) -> std::result::Result<tonic::Response<super::McpServers>, tonic::Status>;
        async fn update_mcp_timeout(
            &self,
            request: tonic::Request<super::UpdateMcpTimeoutRequest>,
        ) -> std::result::Result<tonic::Response<super::McpServers>, tonic::Status>;
        async fn add_remote_mcp_server(
            &self,
            request: tonic::Request<super::AddRemoteMcpServerRequest>,
        ) -> std::result::Result<tonic::Response<super::McpServers>, tonic::Status>;
        async fn download_mcp(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<
            tonic::Response<super::McpDownloadResponse>,
            tonic::Status,
        >;
        async fn restart_mcp_server(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::McpServers>, tonic::Status>;
        async fn delete_mcp_server(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::McpServers>, tonic::Status>;
        async fn toggle_tool_auto_approve(
            &self,
            request: tonic::Request<super::ToggleToolAutoApproveRequest>,
        ) -> std::result::Result<tonic::Response<super::McpServers>, tonic::Status>;
        async fn refresh_mcp_marketplace(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::McpMarketplaceCatalog>,
            tonic::Status,
        >;
        async fn open_mcp_settings(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        /// Server streaming response type for the subscribeToMcpMarketplaceCatalog method.
        type subscribeToMcpMarketplaceCatalogStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::McpMarketplaceCatalog, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to MCP marketplace catalog updates
        async fn subscribe_to_mcp_marketplace_catalog(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::subscribeToMcpMarketplaceCatalogStream>,
            tonic::Status,
        >;
        async fn get_latest_mcp_servers(
            &self,
            request: tonic::Request<super::Empty>,
        ) -> std::result::Result<tonic::Response<super::McpServers>, tonic::Status>;
        /// Server streaming response type for the subscribeToMcpServers method.
        type subscribeToMcpServersStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::McpServers, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to MCP server updates
        async fn subscribe_to_mcp_servers(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::subscribeToMcpServersStream>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct McpServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> McpServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for McpServiceServer<T>
    where
        T: McpService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/cline.McpService/toggleMcpServer" => {
                    #[allow(non_camel_case_types)]
                    struct toggleMcpServerSvc<T: McpService>(pub Arc<T>);
                    impl<
                        T: McpService,
                    > tonic::server::UnaryService<super::ToggleMcpServerRequest>
                    for toggleMcpServerSvc<T> {
                        type Response = super::McpServers;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ToggleMcpServerRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as McpService>::toggle_mcp_server(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = toggleMcpServerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.McpService/updateMcpTimeout" => {
                    #[allow(non_camel_case_types)]
                    struct updateMcpTimeoutSvc<T: McpService>(pub Arc<T>);
                    impl<
                        T: McpService,
                    > tonic::server::UnaryService<super::UpdateMcpTimeoutRequest>
                    for updateMcpTimeoutSvc<T> {
                        type Response = super::McpServers;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateMcpTimeoutRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as McpService>::update_mcp_timeout(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = updateMcpTimeoutSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.McpService/addRemoteMcpServer" => {
                    #[allow(non_camel_case_types)]
                    struct addRemoteMcpServerSvc<T: McpService>(pub Arc<T>);
                    impl<
                        T: McpService,
                    > tonic::server::UnaryService<super::AddRemoteMcpServerRequest>
                    for addRemoteMcpServerSvc<T> {
                        type Response = super::McpServers;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddRemoteMcpServerRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as McpService>::add_remote_mcp_server(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = addRemoteMcpServerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.McpService/downloadMcp" => {
                    #[allow(non_camel_case_types)]
                    struct downloadMcpSvc<T: McpService>(pub Arc<T>);
                    impl<T: McpService> tonic::server::UnaryService<super::StringRequest>
                    for downloadMcpSvc<T> {
                        type Response = super::McpDownloadResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as McpService>::download_mcp(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = downloadMcpSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.McpService/restartMcpServer" => {
                    #[allow(non_camel_case_types)]
                    struct restartMcpServerSvc<T: McpService>(pub Arc<T>);
                    impl<T: McpService> tonic::server::UnaryService<super::StringRequest>
                    for restartMcpServerSvc<T> {
                        type Response = super::McpServers;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as McpService>::restart_mcp_server(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = restartMcpServerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.McpService/deleteMcpServer" => {
                    #[allow(non_camel_case_types)]
                    struct deleteMcpServerSvc<T: McpService>(pub Arc<T>);
                    impl<T: McpService> tonic::server::UnaryService<super::StringRequest>
                    for deleteMcpServerSvc<T> {
                        type Response = super::McpServers;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as McpService>::delete_mcp_server(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = deleteMcpServerSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.McpService/toggleToolAutoApprove" => {
                    #[allow(non_camel_case_types)]
                    struct toggleToolAutoApproveSvc<T: McpService>(pub Arc<T>);
                    impl<
                        T: McpService,
                    > tonic::server::UnaryService<super::ToggleToolAutoApproveRequest>
                    for toggleToolAutoApproveSvc<T> {
                        type Response = super::McpServers;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ToggleToolAutoApproveRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as McpService>::toggle_tool_auto_approve(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = toggleToolAutoApproveSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.McpService/refreshMcpMarketplace" => {
                    #[allow(non_camel_case_types)]
                    struct refreshMcpMarketplaceSvc<T: McpService>(pub Arc<T>);
                    impl<T: McpService> tonic::server::UnaryService<super::EmptyRequest>
                    for refreshMcpMarketplaceSvc<T> {
                        type Response = super::McpMarketplaceCatalog;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as McpService>::refresh_mcp_marketplace(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = refreshMcpMarketplaceSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.McpService/openMcpSettings" => {
                    #[allow(non_camel_case_types)]
                    struct openMcpSettingsSvc<T: McpService>(pub Arc<T>);
                    impl<T: McpService> tonic::server::UnaryService<super::EmptyRequest>
                    for openMcpSettingsSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as McpService>::open_mcp_settings(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = openMcpSettingsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.McpService/subscribeToMcpMarketplaceCatalog" => {
                    #[allow(non_camel_case_types)]
                    struct subscribeToMcpMarketplaceCatalogSvc<T: McpService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: McpService,
                    > tonic::server::ServerStreamingService<super::EmptyRequest>
                    for subscribeToMcpMarketplaceCatalogSvc<T> {
                        type Response = super::McpMarketplaceCatalog;
                        type ResponseStream = T::subscribeToMcpMarketplaceCatalogStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as McpService>::subscribe_to_mcp_marketplace_catalog(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = subscribeToMcpMarketplaceCatalogSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.McpService/getLatestMcpServers" => {
                    #[allow(non_camel_case_types)]
                    struct getLatestMcpServersSvc<T: McpService>(pub Arc<T>);
                    impl<T: McpService> tonic::server::UnaryService<super::Empty>
                    for getLatestMcpServersSvc<T> {
                        type Response = super::McpServers;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::Empty>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as McpService>::get_latest_mcp_servers(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = getLatestMcpServersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.McpService/subscribeToMcpServers" => {
                    #[allow(non_camel_case_types)]
                    struct subscribeToMcpServersSvc<T: McpService>(pub Arc<T>);
                    impl<
                        T: McpService,
                    > tonic::server::ServerStreamingService<super::EmptyRequest>
                    for subscribeToMcpServersSvc<T> {
                        type Response = super::McpServers;
                        type ResponseStream = T::subscribeToMcpServersStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as McpService>::subscribe_to_mcp_servers(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = subscribeToMcpServersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for McpServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "cline.McpService";
    impl<T> tonic::server::NamedService for McpServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod slash_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SlashServiceServer.
    #[async_trait]
    pub trait SlashService: std::marker::Send + std::marker::Sync + 'static {
        /// Sends button click message
        async fn report_bug(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        async fn condense(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
    }
    /// SlashService provides methods for managing slash
    #[derive(Debug)]
    pub struct SlashServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> SlashServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for SlashServiceServer<T>
    where
        T: SlashService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/cline.SlashService/reportBug" => {
                    #[allow(non_camel_case_types)]
                    struct reportBugSvc<T: SlashService>(pub Arc<T>);
                    impl<
                        T: SlashService,
                    > tonic::server::UnaryService<super::StringRequest>
                    for reportBugSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SlashService>::report_bug(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = reportBugSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.SlashService/condense" => {
                    #[allow(non_camel_case_types)]
                    struct condenseSvc<T: SlashService>(pub Arc<T>);
                    impl<
                        T: SlashService,
                    > tonic::server::UnaryService<super::StringRequest>
                    for condenseSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SlashService>::condense(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = condenseSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for SlashServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "cline.SlashService";
    impl<T> tonic::server::NamedService for SlashServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IsImageUrl {
    #[prost(bool, tag = "1")]
    pub is_image: bool,
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenGraphData {
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub image: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub url: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub site_name: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub r#type: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod web_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with WebServiceServer.
    #[async_trait]
    pub trait WebService: std::marker::Send + std::marker::Sync + 'static {
        async fn check_is_image_url(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::IsImageUrl>, tonic::Status>;
        async fn fetch_open_graph_data(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::OpenGraphData>, tonic::Status>;
        async fn open_in_browser(
            &self,
            request: tonic::Request<super::StringRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
    }
    #[derive(Debug)]
    pub struct WebServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> WebServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for WebServiceServer<T>
    where
        T: WebService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/cline.WebService/checkIsImageUrl" => {
                    #[allow(non_camel_case_types)]
                    struct checkIsImageUrlSvc<T: WebService>(pub Arc<T>);
                    impl<T: WebService> tonic::server::UnaryService<super::StringRequest>
                    for checkIsImageUrlSvc<T> {
                        type Response = super::IsImageUrl;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WebService>::check_is_image_url(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = checkIsImageUrlSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.WebService/fetchOpenGraphData" => {
                    #[allow(non_camel_case_types)]
                    struct fetchOpenGraphDataSvc<T: WebService>(pub Arc<T>);
                    impl<T: WebService> tonic::server::UnaryService<super::StringRequest>
                    for fetchOpenGraphDataSvc<T> {
                        type Response = super::OpenGraphData;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WebService>::fetch_open_graph_data(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = fetchOpenGraphDataSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.WebService/openInBrowser" => {
                    #[allow(non_camel_case_types)]
                    struct openInBrowserSvc<T: WebService>(pub Arc<T>);
                    impl<T: WebService> tonic::server::UnaryService<super::StringRequest>
                    for openInBrowserSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StringRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WebService>::open_in_browser(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = openInBrowserSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for WebServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "cline.WebService";
    impl<T> tonic::server::NamedService for WebServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthStateChangedRequest {
    #[prost(message, optional, tag = "1")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(message, optional, tag = "2")]
    pub user: ::core::option::Option<UserInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthState {
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<UserInfo>,
}
/// User's information
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserInfo {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub email: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub photo_url: ::core::option::Option<::prost::alloc::string::String>,
    /// Cline app base URL
    #[prost(string, optional, tag = "5")]
    pub app_base_url: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserOrganization {
    #[prost(bool, tag = "1")]
    pub active: bool,
    #[prost(string, tag = "2")]
    pub member_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub organization_id: ::prost::alloc::string::String,
    /// \["admin", "member", "owner"\]
    #[prost(string, repeated, tag = "5")]
    pub roles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserOrganizationsResponse {
    #[prost(message, repeated, tag = "1")]
    pub organizations: ::prost::alloc::vec::Vec<UserOrganization>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserOrganizationUpdateRequest {
    #[prost(string, optional, tag = "1")]
    pub organization_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserCreditsData {
    #[prost(message, optional, tag = "1")]
    pub balance: ::core::option::Option<UserCreditsBalance>,
    #[prost(message, repeated, tag = "2")]
    pub usage_transactions: ::prost::alloc::vec::Vec<UsageTransaction>,
    #[prost(message, repeated, tag = "3")]
    pub payment_transactions: ::prost::alloc::vec::Vec<PaymentTransaction>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetOrganizationCreditsRequest {
    #[prost(string, tag = "1")]
    pub organization_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrganizationCreditsData {
    #[prost(message, optional, tag = "1")]
    pub balance: ::core::option::Option<UserCreditsBalance>,
    #[prost(string, tag = "2")]
    pub organization_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub usage_transactions: ::prost::alloc::vec::Vec<OrganizationUsageTransaction>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserCreditsBalance {
    #[prost(double, tag = "1")]
    pub current_balance: f64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsageTransaction {
    #[prost(string, tag = "1")]
    pub ai_inference_provider_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub ai_model_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub ai_model_type_name: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub completion_tokens: i32,
    #[prost(double, tag = "5")]
    pub cost_usd: f64,
    #[prost(string, tag = "6")]
    pub created_at: ::prost::alloc::string::String,
    #[prost(double, tag = "7")]
    pub credits_used: f64,
    #[prost(string, tag = "8")]
    pub generation_id: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub organization_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "10")]
    pub prompt_tokens: i32,
    #[prost(int32, tag = "11")]
    pub total_tokens: i32,
    #[prost(string, tag = "12")]
    pub user_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaymentTransaction {
    #[prost(string, tag = "1")]
    pub paid_at: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub creator_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub amount_cents: i32,
    #[prost(double, tag = "4")]
    pub credits: f64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrganizationUsageTransaction {
    #[prost(string, tag = "1")]
    pub ai_inference_provider_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub ai_model_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub ai_model_type_name: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub completion_tokens: i32,
    #[prost(double, tag = "5")]
    pub cost_usd: f64,
    #[prost(string, tag = "6")]
    pub created_at: ::prost::alloc::string::String,
    #[prost(double, tag = "7")]
    pub credits_used: f64,
    #[prost(string, tag = "8")]
    pub generation_id: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub organization_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "10")]
    pub prompt_tokens: i32,
    #[prost(int32, tag = "11")]
    pub total_tokens: i32,
    #[prost(string, tag = "12")]
    pub user_id: ::prost::alloc::string::String,
}
/// Generated server implementations.
pub mod account_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AccountServiceServer.
    #[async_trait]
    pub trait AccountService: std::marker::Send + std::marker::Sync + 'static {
        /// Handles the user clicking the login link in the UI.
        /// Generates a secure nonce for state validation, stores it in secrets,
        /// and opens the authentication URL in the external browser.
        async fn account_login_clicked(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<tonic::Response<super::String>, tonic::Status>;
        /// Handles the user clicking the logout button in the UI.
        /// Clears API keys and user state.
        async fn account_logout_clicked(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        /// Server streaming response type for the subscribeToAuthStatusUpdate method.
        type subscribeToAuthStatusUpdateStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::AuthState, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to auth status update events (when authentication state changes)
        async fn subscribe_to_auth_status_update(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::subscribeToAuthStatusUpdateStream>,
            tonic::Status,
        >;
        /// Handles authentication state changes from the Firebase context.
        /// Updates the user info in global state and returns the updated value.
        async fn auth_state_changed(
            &self,
            request: tonic::Request<super::AuthStateChangedRequest>,
        ) -> std::result::Result<tonic::Response<super::AuthState>, tonic::Status>;
        /// Fetches all user credits data
        /// (balance, usage transactions, payment transactions)
        async fn get_user_credits(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<tonic::Response<super::UserCreditsData>, tonic::Status>;
        async fn get_organization_credits(
            &self,
            request: tonic::Request<super::GetOrganizationCreditsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OrganizationCreditsData>,
            tonic::Status,
        >;
        /// Fetches all user organizations data
        /// Returns a list of UserOrganization objects
        async fn get_user_organizations(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UserOrganizationsResponse>,
            tonic::Status,
        >;
        async fn set_user_organization(
            &self,
            request: tonic::Request<super::UserOrganizationUpdateRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
        async fn openrouter_auth_clicked(
            &self,
            request: tonic::Request<super::EmptyRequest>,
        ) -> std::result::Result<tonic::Response<super::Empty>, tonic::Status>;
    }
    /// Service for account-related operations
    #[derive(Debug)]
    pub struct AccountServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AccountServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AccountServiceServer<T>
    where
        T: AccountService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/cline.AccountService/accountLoginClicked" => {
                    #[allow(non_camel_case_types)]
                    struct accountLoginClickedSvc<T: AccountService>(pub Arc<T>);
                    impl<
                        T: AccountService,
                    > tonic::server::UnaryService<super::EmptyRequest>
                    for accountLoginClickedSvc<T> {
                        type Response = super::String;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AccountService>::account_login_clicked(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = accountLoginClickedSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.AccountService/accountLogoutClicked" => {
                    #[allow(non_camel_case_types)]
                    struct accountLogoutClickedSvc<T: AccountService>(pub Arc<T>);
                    impl<
                        T: AccountService,
                    > tonic::server::UnaryService<super::EmptyRequest>
                    for accountLogoutClickedSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AccountService>::account_logout_clicked(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = accountLogoutClickedSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.AccountService/subscribeToAuthStatusUpdate" => {
                    #[allow(non_camel_case_types)]
                    struct subscribeToAuthStatusUpdateSvc<T: AccountService>(pub Arc<T>);
                    impl<
                        T: AccountService,
                    > tonic::server::ServerStreamingService<super::EmptyRequest>
                    for subscribeToAuthStatusUpdateSvc<T> {
                        type Response = super::AuthState;
                        type ResponseStream = T::subscribeToAuthStatusUpdateStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AccountService>::subscribe_to_auth_status_update(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = subscribeToAuthStatusUpdateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.AccountService/authStateChanged" => {
                    #[allow(non_camel_case_types)]
                    struct authStateChangedSvc<T: AccountService>(pub Arc<T>);
                    impl<
                        T: AccountService,
                    > tonic::server::UnaryService<super::AuthStateChangedRequest>
                    for authStateChangedSvc<T> {
                        type Response = super::AuthState;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AuthStateChangedRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AccountService>::auth_state_changed(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = authStateChangedSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.AccountService/getUserCredits" => {
                    #[allow(non_camel_case_types)]
                    struct getUserCreditsSvc<T: AccountService>(pub Arc<T>);
                    impl<
                        T: AccountService,
                    > tonic::server::UnaryService<super::EmptyRequest>
                    for getUserCreditsSvc<T> {
                        type Response = super::UserCreditsData;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AccountService>::get_user_credits(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = getUserCreditsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.AccountService/getOrganizationCredits" => {
                    #[allow(non_camel_case_types)]
                    struct getOrganizationCreditsSvc<T: AccountService>(pub Arc<T>);
                    impl<
                        T: AccountService,
                    > tonic::server::UnaryService<super::GetOrganizationCreditsRequest>
                    for getOrganizationCreditsSvc<T> {
                        type Response = super::OrganizationCreditsData;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetOrganizationCreditsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AccountService>::get_organization_credits(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = getOrganizationCreditsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.AccountService/getUserOrganizations" => {
                    #[allow(non_camel_case_types)]
                    struct getUserOrganizationsSvc<T: AccountService>(pub Arc<T>);
                    impl<
                        T: AccountService,
                    > tonic::server::UnaryService<super::EmptyRequest>
                    for getUserOrganizationsSvc<T> {
                        type Response = super::UserOrganizationsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AccountService>::get_user_organizations(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = getUserOrganizationsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.AccountService/setUserOrganization" => {
                    #[allow(non_camel_case_types)]
                    struct setUserOrganizationSvc<T: AccountService>(pub Arc<T>);
                    impl<
                        T: AccountService,
                    > tonic::server::UnaryService<super::UserOrganizationUpdateRequest>
                    for setUserOrganizationSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UserOrganizationUpdateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AccountService>::set_user_organization(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = setUserOrganizationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cline.AccountService/openrouterAuthClicked" => {
                    #[allow(non_camel_case_types)]
                    struct openrouterAuthClickedSvc<T: AccountService>(pub Arc<T>);
                    impl<
                        T: AccountService,
                    > tonic::server::UnaryService<super::EmptyRequest>
                    for openrouterAuthClickedSvc<T> {
                        type Response = super::Empty;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EmptyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AccountService>::openrouter_auth_clicked(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = openrouterAuthClickedSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AccountServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "cline.AccountService";
    impl<T> tonic::server::NamedService for AccountServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
